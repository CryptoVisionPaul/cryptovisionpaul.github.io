<!DOCTYPE html>
<html lang="en">
<head>
  <!-- (Optional) AdSense loader - keep if you already use it -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9902358545401183"
    crossorigin="anonymous"></script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CryptoVision – AI Crypto Insights</title>
  <meta name="description" content="CryptoVision – live crypto prices + AI insights. Backend proxy + fallback." />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --bg:#050816;
      --bg2:#081026;
      --accent:#22c55e;
      --accent-soft:rgba(34,197,94,.15);
      --danger:#f97373;
      --danger-soft:rgba(248,113,113,.15);
      --warning:#eab308;
      --text:#e5e7eb;
      --text-soft:#9ca3af;
      --border:#1f2937;
      --card:#0f172a;
      --card-soft:rgba(15,23,42,.9);
      --shadow:0 22px 60px rgba(0,0,0,.55);
      --font:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      min-height:100vh;
      font-family:var(--font);
      background:radial-gradient(circle at top,#111827,#020617);
      color:var(--text);
      display:flex;
      justify-content:center;
      padding:24px 12px;
    }
    .shell{
      width:100%;
      max-width:1720px;
      background:linear-gradient(135deg,#020617,#020617 40%,#020617 60%,#020617);
      border-radius:32px;
      box-shadow:var(--shadow);
      padding:24px 24px 28px;
      border:1px solid rgba(148,163,184,.25);
      position:relative;
      overflow:hidden;
    }
    .shell::before{
      content:"";
      position:absolute; inset:-40%;
      background:
        radial-gradient(circle at 0% 0%, rgba(56,189,248,.11), transparent 55%),
        radial-gradient(circle at 100% 0%, rgba(79,70,229,.11), transparent 55%),
        radial-gradient(circle at 50% 100%, rgba(34,197,94,.12), transparent 55%);
      opacity:.9; pointer-events:none; z-index:-1;
    }

    .top-bar{
      display:flex; justify-content:space-between; gap:16px;
      align-items:center; margin-bottom:18px; flex-wrap:wrap;
    }
    .logo-wrap{display:flex; align-items:center; gap:14px}
    .logo-badge{
      width:40px;height:40px;border-radius:999px;
      background:radial-gradient(circle at 30% 20%,#4ade80,#22c55e);
      display:flex;align-items:center;justify-content:center;
      color:#020617;font-weight:800;font-size:18px;
      box-shadow:0 0 0 1px rgba(15,23,42,.5),0 18px 38px rgba(22,163,74,.55);
    }
    .title-block h1{
      font-size:22px; letter-spacing:.03em;
      display:flex; align-items:center; gap:8px;
    }
    .title-pill{
      font-size:11px; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(96,165,250,.7);
      color:#bfdbfe;
      background:linear-gradient(135deg,rgba(37,99,235,.45),rgba(56,189,248,.1));
      text-transform:uppercase;
    }
    .title-block p{font-size:13px;color:var(--text-soft);margin-top:3px}

    .status-wrap{display:flex; flex-direction:column; align-items:flex-end; gap:6px; font-size:12px}
    .live-badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 10px; border-radius:999px;
      background:rgba(22,163,74,.12); color:#bbf7d0;
      border:1px solid rgba(34,197,94,.6);
      font-size:11px; text-transform:uppercase; letter-spacing:.08em;
    }
    .dot{width:8px;height:8px;border-radius:999px;background:#22c55e;box-shadow:0 0 0 4px rgba(34,197,94,.3)}
    .updated-at{font-size:12px;color:var(--text-soft)}
    .source-badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(148,163,184,.35);
      background:rgba(15,23,42,.6);
      color:#cbd5e1; font-size:11px;
      max-width:100%;
    }
    .source-dot{
      width:8px;height:8px;border-radius:999px; background:#60a5fa;
      box-shadow:0 0 0 4px rgba(96,165,250,.18);
      flex:0 0 auto;
    }
    .source-dot.ok{background:#22c55e; box-shadow:0 0 0 4px rgba(34,197,94,.18);}
    .source-dot.warn{background:#eab308; box-shadow:0 0 0 4px rgba(234,179,8,.18);}
    .source-dot.bad{background:#f97373; box-shadow:0 0 0 4px rgba(249,115,115,.18);}
    .source-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}

    .grid-top{
      display:grid; grid-template-columns:minmax(0,3fr) minmax(0,2fr);
      gap:18px; margin-bottom:16px;
    }
    .pill-row{display:flex; flex-wrap:wrap; gap:10px}
    .feature-pill{
      display:flex; align-items:center; gap:6px;
      padding:7px 10px; border-radius:999px; font-size:11px;
      background:rgba(15,23,42,.8);
      border:1px solid rgba(148,163,184,.35);
      backdrop-filter:blur(16px);
    }
    .feature-pill span.icon{
      width:16px;height:16px;border-radius:999px;
      display:inline-flex; align-items:center; justify-content:center;
      font-size:11px;
    }
    .feature-pill.good span.icon{background:rgba(34,197,94,.18);color:#bbf7d0}
    .feature-pill.info span.icon{background:rgba(59,130,246,.18);color:#bfdbfe}
    .feature-pill.ad span.icon{background:rgba(234,179,8,.18);color:#fef9c3}
    .mini-note{font-size:11px;color:#9ca3af;margin-top:6px}

    .top-info-card{
      padding:10px 14px; border-radius:18px;
      background:rgba(15,23,42,.88);
      border:1px solid rgba(148,163,184,.35);
      backdrop-filter:blur(16px); font-size:12px;
    }
    .top-info-card strong{color:#e5e7eb}

    .main-grid{
      display:grid;
      grid-template-columns:minmax(0,3.3fr) minmax(0,2.7fr);
      gap:18px;
    }
    .card{
      background:var(--card-soft);
      border-radius:22px;
      padding:14px 14px 16px;
      border:1px solid rgba(148,163,184,.3);
      box-shadow:0 18px 45px rgba(15,23,42,.9);
      backdrop-filter:blur(18px);
      position:relative; overflow:hidden;
    }

    .card-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:10px}
    .card-title{font-size:14px;font-weight:600}
    .card-subtitle{font-size:11px;color:var(--text-soft)}
    .badge{
      padding:3px 8px; border-radius:999px;
      font-size:10px; letter-spacing:.06em; text-transform:uppercase;
      border:1px solid rgba(148,163,184,.5); color:#e5e7eb;
    }
    .badge.green{border-color:rgba(34,197,94,.7);background:rgba(22,163,74,.12);color:#bbf7d0}
    .badge.blue{border-color:rgba(59,130,246,.7);background:rgba(37,99,235,.18);color:#bfdbfe}
    .badge.orange{border-color:rgba(234,179,8,.7);background:rgba(234,179,8,.16);color:#fef3c7}
    .badge.gray{border-color:rgba(148,163,184,.35);background:rgba(15,23,42,.5);color:#e5e7eb}

    .toolbar{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px;align-items:center;font-size:12px}
    .search-box{flex:1}
    .search-input{
      width:100%; padding:7px 9px; border-radius:999px;
      border:1px solid rgba(148,163,184,.35);
      background:rgba(15,23,42,.9); color:var(--text);
      font-size:12px; outline:none;
    }
    .search-input::placeholder{color:#6b7280}
    .select-small,.btn-small{
      border-radius:999px; border:1px solid rgba(148,163,184,.4);
      background:rgba(15,23,42,.9); color:var(--text-soft);
      font-size:11px; padding:6px 9px; outline:none; cursor:pointer;
    }
    .btn-small.primary{
      background:linear-gradient(to right,#2563eb,#22c55e);
      border-color:transparent; color:#ecfeff; font-weight:500;
    }
    .btn-small.secondary{
      background:rgba(15,23,42,.92);
      border:1px solid rgba(96,165,250,.6);
      color:#bfdbfe;
    }
    .btn-small.danger{
      background:rgba(248,113,113,.12);
      border:1px solid rgba(248,113,113,.65);
      color:#fecaca;
    }
    .btn-small[disabled]{opacity:.55; cursor:not-allowed; filter:none;}

    .table-wrap{
      max-height:420px; overflow:auto; border-radius:16px;
      border:1px solid rgba(31,41,55,.9);
      background:radial-gradient(circle at top, rgba(15,23,42,.96), #020617);
    }
    table{width:100%; border-collapse:collapse; font-size:12px}
    thead{
      background:rgba(15,23,42,.95);
      position:sticky; top:0; z-index:2;
    }
    th,td{
      padding:7px 10px; text-align:right;
      border-bottom:1px solid rgba(31,41,55,.9);
      white-space:nowrap;
    }
    th:first-child,td:first-child{text-align:left}
    th:nth-child(2),td:nth-child(2){text-align:left}
    th{
      font-size:11px; color:#9ca3af;
      text-transform:uppercase; letter-spacing:.06em;
    }
    tbody tr{cursor:pointer; transition:background .15s ease-out}
    tbody tr:nth-child(even){background:rgba(15,23,42,.85)}
    tbody tr:hover{background:rgba(37,99,235,.18)}
    .rank{color:#6b7280;font-size:11px}
    .coin-name{display:flex; align-items:center; gap:6px}
    .coin-symbol{
      font-size:10px; text-transform:uppercase; color:#9ca3af;
      padding:1px 5px; border-radius:999px;
      background:rgba(15,23,42,.9);
      border:1px solid rgba(55,65,81,.9);
    }
    .chg-pos{color:#22c55e}
    .chg-neg{color:#f97373}

    .ai-text{font-size:12px; line-height:1.55; color:#e5e7eb}
    .ai-text strong{color:#bfdbfe}
    .ai-list{margin-top:8px; list-style:none; font-size:12px; color:#cbd5f5}
    .ai-list li{margin-bottom:4px; position:relative; padding-left:14px}
    .ai-list li::before{content:"•"; position:absolute; left:2px; color:#60a5fa}

    .small-label{font-size:11px; color:#9ca3af; margin-bottom:4px}
    .pair-header{display:flex; justify-content:space-between; align-items:baseline; margin-bottom:4px; gap:4px; flex-wrap:wrap}
    .pair-name{font-size:14px; font-weight:600}
    .pair-symbol{font-size:11px; text-transform:uppercase; color:#9ca3af}
    .big-price{font-size:20px; font-weight:600}

    .pill-row-small{display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 10px; font-size:11px}
    .pill-info{
      padding:3px 7px; border-radius:999px;
      border:1px solid rgba(148,163,184,.45);
      color:#e5e7eb; background:rgba(15,23,42,.9);
    }
    .pill-info.green{border-color:rgba(34,197,94,.7); background:var(--accent-soft); color:#bbf7d0}
    .pill-info.red{border-color:rgba(248,113,113,.75); background:var(--danger-soft); color:#fecaca}

    .metric-grid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px; font-size:11px; margin-bottom:10px}
    .metric-item{
      padding:6px 8px; border-radius:12px;
      background:rgba(15,23,42,.9);
      border:1px solid rgba(30,64,175,.8);
    }
    .metric-label{color:#9ca3af; margin-bottom:2px}
    .metric-value{font-weight:600}
    .metric-note{font-size:10px; color:#9ca3af; margin-top:2px}

    .ai-comment{
      margin-top:2px;
      padding:7px 9px;
      border-radius:12px;
      background:rgba(15,23,42,.9);
      border:1px dashed rgba(148,163,184,.7);
      font-size:12px; line-height:1.5;
      color:#e5e7eb;
    }

    .scenario-block{margin-top:8px; font-size:11px}
    .scenario-block strong{color:#bfdbfe}
    .scenario-list{list-style:none; margin-top:6px}
    .scenario-list li{margin-bottom:8px; line-height:1.35}

    .chart-wrap{
      margin-top:10px;
      background:radial-gradient(circle at top, rgba(30,64,175,.4), #020617);
      border-radius:14px;
      padding:8px 8px 4px;
      border:1px solid rgba(30,64,175,.8);
    }
    .chart-wrap canvas{width:100%; height:210px; max-height:210px}

    .ad-card{
      margin-top:12px;
      padding:10px 12px;
      border-radius:16px;
      border:1px dashed rgba(234,179,8,.7);
      background:rgba(24,16,3,.8);
      font-size:11px; color:#fef9c3;
    }
    .ad-card strong{color:#facc15}

    .footer-note{margin-top:10px; font-size:10px; color:#6b7280; text-align:right}

    .backend-grid{
      display:grid;
      grid-template-columns:minmax(0,1fr) minmax(0,1fr);
      gap:12px;
      margin-top:16px;
    }
    .panel{
      border-radius:18px;
      border:1px solid rgba(148,163,184,.25);
      background:rgba(15,23,42,.75);
      padding:14px;
    }
    .panel h2,.panel h3{font-size:14px; margin-bottom:8px}
    .panel p{font-size:12px; color:var(--text-soft); line-height:1.5}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:10px 0}
    .input{
      padding:7px 10px; border-radius:10px;
      border:1px solid rgba(148,163,184,.35);
      background:#020617; color:#f9fafb;
      min-width:180px; outline:none;
    }
    .btn{
      padding:7px 14px; border-radius:999px;
      border:none; background:#22c55e; color:#020617;
      font-weight:800; cursor:pointer;
    }
    .btn:hover{filter:brightness(1.05)}
    .btn[disabled]{opacity:.55; cursor:not-allowed; filter:none;}
    pre{
      max-height:260px; overflow:auto;
      background:#020617; border-radius:12px;
      padding:10px; font-size:12px;
      border:1px solid #1f2937; color:#e5e7eb;
      white-space:pre-wrap;
    }

    .controls-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin:8px 0 10px;
    }
    .controls-row .select-small{color:#e5e7eb}
    .hint{
      font-size:11px;
      color:var(--text-soft);
      margin-top:6px;
      line-height:1.4;
    }

    @media (max-width: 900px){
      body{padding:12px 6px}
      .shell{border-radius:20px; padding:14px}
      .grid-top,.main-grid,.backend-grid{grid-template-columns:minmax(0,1fr)}
      .status-wrap{align-items:flex-start}
      .table-wrap{max-height:360px}
    }
  </style>
</head>

<body>
  <div class="shell">

    <header class="top-bar">
      <div class="logo-wrap">
        <div class="logo-badge">CV</div>
        <div class="title-block">
          <h1>CryptoVision <span class="title-pill">AI Crypto Insights</span></h1>
          <p>Live crypto prices + AI insights. (Backend proxy + fallback)</p>
        </div>
      </div>
      <div class="status-wrap">
        <div class="live-badge"><span class="dot"></span><span>Live market feed (real-time-ish)</span></div>
        <div class="updated-at" id="updatedAtText">Updated: —</div>
        <div class="source-badge" title="Data source status">
          <span id="sourceDot" class="source-dot warn"></span>
          <span id="sourceText" class="source-text">Source: checking…</span>
        </div>
      </div>
    </header>

    <section class="grid-top">
      <div>
        <div class="pill-row">
          <div class="feature-pill good"><span class="icon">✓</span><span class="label">Top 50 markets (backend proxy)</span></div>
          <div class="feature-pill good"><span class="icon">✓</span><span class="label">CoinGecko fallback (auto)</span></div>
          <div class="feature-pill info"><span class="icon">AI</span><span class="label">Worldwide scenario format</span></div>
          <div class="feature-pill info"><span class="icon">UX</span><span class="label">Modern blue + dark UI</span></div>
          <div class="feature-pill ad"><span class="icon">Ad</span><span class="label">AdSense / affiliate area</span></div>
          <div class="feature-pill info"><span class="icon">∞</span><span class="label">Ready for subscription</span></div>
        </div>
        <p class="mini-note">
          Markets load via the Render backend proxy. If the backend is sleeping/down, the app falls back to CoinGecko directly.
        </p>
      </div>

      <div class="top-info-card">
        <div class="card-header" style="margin-bottom:6px;">
          <div>
            <div class="card-title">CryptoVision AI module</div>
            <div class="card-subtitle">Per-coin prediction + probabilistic scenarios.</div>
          </div>
          <span class="badge blue">Live</span>
        </div>
        <p style="margin-bottom:4px;">
          <strong>How it works:</strong> select a coin and the app calls your backend <code>/ai/predict</code>,
          then formats the output into simple “Bullish / Bearish” probability scenarios.
        </p>
        <p class="mini-note">
          Educational / informational only. Not financial advice.
        </p>
      </div>
    </section>

    <section class="main-grid">
      <article class="card">
        <div class="card-header">
          <div>
            <div class="card-title">Watched coins</div>
            <div class="card-subtitle">Top 50 by market cap – backend proxy + fallback.</div>
          </div>
          <span class="badge gray">USD</span>
        </div>

        <div class="toolbar">
          <div class="search-box">
            <input id="searchInput" class="search-input" type="text" placeholder="Search coin (e.g. bitcoin, eth, bnb)..." />
          </div>
          <select id="sortSelect" class="select-small">
            <option value="rank">Sort: Market Cap</option>
            <option value="change24">Sort: Biggest 24h moves</option>
            <option value="change1h">Sort: Biggest 1h moves</option>
            <option value="change7d">Sort: Biggest 7d moves</option>
          </select>
          <button id="refreshBtn" class="btn-small primary" title="Manual refresh is rate-limited to 60s">Refresh</button>
        </div>

        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Coin</th>
                <th>Price</th>
                <th>1h</th>
                <th>24h</th>
                <th>7d</th>
                <th>Market Cap</th>
              </tr>
            </thead>
            <tbody id="coinsBody"></tbody>
          </table>
        </div>
      </article>

      <article>
        <div class="card" style="margin-bottom:12px;">
          <div class="card-header">
            <div>
              <div class="card-title">CryptoVision – Daily Insight</div>
              <div class="card-subtitle">Quick summary based on the top 50 coins.</div>
            </div>
            <span class="badge green">Rules</span>
          </div>
          <div class="ai-text" id="dailyInsight">Loading market analysis...</div>
        </div>

        <!-- NEWS CARD (UI already present) -->
        <div class="card" style="margin-bottom:12px;">
          <div class="card-header">
            <div>
              <div class="card-title">CryptoVision – Crypto News</div>
              <div class="card-subtitle">Latest headlines (via backend RSS aggregator).</div>
            </div>
            <button id="newsRefreshBtn" class="btn-small secondary">Refresh News</button>
          </div>

          <div class="ai-text" id="newsStatus">Loading news…</div>
          <ul class="ai-list" id="newsList" style="margin-top:10px;"></ul>
        </div>

        <div class="card">
          <div class="card-header">
            <div>
              <div class="card-title">Selected coin analysis</div>
              <div class="card-subtitle">Click a coin in the list to get AI scenarios + chart.</div>
            </div>
            <span class="badge orange">Focus asset</span>
          </div>

          <div class="small-label">Selected</div>
          <div class="pair-header">
            <div>
              <div class="pair-name" id="selectedName">No coin selected</div>
              <div class="pair-symbol" id="selectedSymbol">Choose from the list</div>
            </div>
            <div class="big-price" id="selectedPrice">—</div>
          </div>

          <div class="pill-row-small" id="selectedPills">
            <span class="pill-info">Waiting for a selection...</span>
          </div>

          <!-- AI Controls -->
          <div class="controls-row">
            <select id="tfSelect" class="select-small" title="AI timeframe">
              <option value="30m">TF: 30m</option>
              <option value="1h">TF: 1h</option>
              <option value="4h">TF: 4h</option>
              <option value="1d" selected>TF: 1d</option>
            </select>
            <select id="daysSelect" class="select-small" title="History window used by AI">
              <option value="30">History: 30d</option>
              <option value="90" selected>History: 90d</option>
              <option value="180">History: 180d</option>
              <option value="365">History: 365d</option>
            </select>
            <button id="btnRetryAi" class="btn-small secondary" disabled>Retry AI</button>
            <button id="btnClearCache" class="btn-small danger" title="Clears local cache (markets + charts + ai + news)">Clear cache</button>
          </div>
          <div class="hint" id="aiHint">
            Tip: if AI is rate-limited, the app will show a clear retry countdown. Scenarios stay in English for worldwide use.
          </div>

          <div class="metric-grid">
            <div class="metric-item">
              <div class="metric-label">Market Cap</div>
              <div class="metric-value" id="metricMarketCap">—</div>
              <div class="metric-note">Project size vs market.</div>
            </div>
            <div class="metric-item">
              <div class="metric-label">AI / RSI</div>
              <div class="metric-value" id="metricBias">—</div>
              <div class="metric-note">From backend prediction.</div>
            </div>
          </div>

          <div class="ai-comment" id="coinComment">
            Select a coin to load AI prediction and probabilistic scenarios.
          </div>

          <div class="scenario-block">
            <strong>Probabilistic scenarios:</strong>
            <ul class="scenario-list" id="scenarioList"><li>—</li></ul>
          </div>

          <div class="chart-wrap">
            <div class="small-label" style="margin-bottom:4px;">Chart – last 30 days (USD)</div>
            <canvas id="priceChart"></canvas>
          </div>

          <div class="ad-card">
            <strong>ADS / AFFILIATE AREA</strong><br/>
            Place your AdSense units or affiliate banners here after approval.
          </div>

          <div class="footer-note">
            Educational / informational only. Not financial advice.
          </div>
        </div>
      </article>
    </section>

    <section class="backend-grid">
      <div class="panel">
        <h2>Backend Test</h2>
        <p>
          Health: <code>/health</code> • AI: <code>/ai/predict</code> (examples: bitcoin, ethereum).
        </p>

        <div class="row">
          <label for="ai-coin-id-input" style="font-size:12px; color:var(--text-soft);">Coin ID:</label>
          <input id="ai-coin-id-input" class="input" type="text" value="bitcoin" />
          <button class="btn" type="button" id="btnTestBackend">Test AI</button>
          <button class="btn" type="button" id="btnHealth" style="background:#60a5fa;">Health</button>
        </div>

        <pre id="ai-backend-result">No request yet.</pre>
      </div>

      <div class="panel">
        <h3>AI Summary</h3>
        <p>This box updates after you call the AI endpoint.</p>
        <div style="display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; margin-top:10px; font-size:12px;">
          <div>
            <div style="opacity:.75;">Coin</div>
            <strong id="ai-summary-coin">-</strong>
          </div>
          <div>
            <div style="opacity:.75;">Last price</div>
            <strong id="ai-summary-last">-</strong>
          </div>
          <div>
            <div style="opacity:.75;">Predicted</div>
            <strong id="ai-summary-predicted">-</strong>
          </div>
          <div>
            <div style="opacity:.75;">RSI</div>
            <strong id="ai-summary-rsi">-</strong>
          </div>
        </div>
      </div>
    </section>

  </div>

  <script>
    // ==========================================================
    // CONFIG
    // ==========================================================
    const API_BASE = "https://api.coingecko.com/api/v3";
    const BACKEND_BASE_URL = "https://cryptovision-ldo7.onrender.com"; // no trailing slash
    const BACKEND_MARKETS_ENDPOINT = "/coins/markets";

    // Front-end rate-limit + cache
    const REFRESH_MIN_INTERVAL_MS = 60_000;
    const MARKETS_CACHE_TTL_MS = 60_000;
    const STORAGE_KEY_MARKETS = "cv_markets_cache_v1";

    // AI cache (browser)
    const AI_CACHE_TTL_MS = 120_000; // 2 minutes

    // NEWS (backend) + cache
    const NEWS_ENDPOINT = "/news";                // backend route must exist
    const NEWS_CACHE_TTL_MS = 5 * 60_000;         // 5 minutes
    const NEWS_REFRESH_MIN_INTERVAL_MS = 30_000;  // protect backend from spam
    const STORAGE_KEY_NEWS = "cv_news_cache_v1";

    // Endpoints
    const AI_ENDPOINT = "/ai/predict";
    const CHART_ENDPOINT = "/chart";

    // Storage keys
    const STORAGE_KEY_PREFS = "cv_prefs_v1";

    // ==========================================================
    // DOM
    // ==========================================================
    const coinsBody = document.getElementById("coinsBody");
    const searchInput = document.getElementById("searchInput");
    const sortSelect = document.getElementById("sortSelect");
    const refreshBtn = document.getElementById("refreshBtn");
    const updatedAtText = document.getElementById("updatedAtText");
    const dailyInsightEl = document.getElementById("dailyInsight");

    const sourceDot = document.getElementById("sourceDot");
    const sourceText = document.getElementById("sourceText");

    const selectedNameEl = document.getElementById("selectedName");
    const selectedSymbolEl = document.getElementById("selectedSymbol");
    const selectedPriceEl = document.getElementById("selectedPrice");
    const selectedPillsEl = document.getElementById("selectedPills");
    const metricMarketCapEl = document.getElementById("metricMarketCap");
    const metricBiasEl = document.getElementById("metricBias");
    const coinCommentEl = document.getElementById("coinComment");
    const scenarioListEl = document.getElementById("scenarioList");

    const aiInput = document.getElementById("ai-coin-id-input");
    const aiResult = document.getElementById("ai-backend-result");
    const btnTestBackend = document.getElementById("btnTestBackend");
    const btnHealth = document.getElementById("btnHealth");

    const tfSelect = document.getElementById("tfSelect");
    const daysSelect = document.getElementById("daysSelect");
    const btnRetryAi = document.getElementById("btnRetryAi");
    const btnClearCache = document.getElementById("btnClearCache");
    const aiHint = document.getElementById("aiHint");

    // NEWS DOM
    const newsListEl = document.getElementById("newsList");
    const newsStatusEl = document.getElementById("newsStatus");
    const newsRefreshBtn = document.getElementById("newsRefreshBtn");

    // ==========================================================
    // STATE
    // ==========================================================
    let coinsRaw = [];
    let filteredCoins = [];
    let currentSort = "rank";
    let priceChart = null;

    const chartCache = new Map(); // coinId -> {labels, values}
    const aiCache = new Map();    // coinId -> { ts, data }

    const DataSource = {
      BACKEND: "backend-proxy",
      COINGECKO: "coingecko-direct",
      CACHE: "cache"
    };

    let isLoadingMarkets = false;
    let lastManualRefreshTs = 0;

    // Selected coin state
    let selectedCoinId = null;
    let aiRetryTimer = null;
    let aiRetryRemainingSec = 0;
    let forceAiRefresh = false;

    // News state
    let lastNewsRefreshTs = 0;

    // ==========================================================
    // UTIL
    // ==========================================================
    function updateTimestamp() {
      const now = new Date();
      const formatted = now.toLocaleString("en-GB", {
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit"
      });
      updatedAtText.textContent = "Updated: " + formatted;
    }

    function safeNum(x) {
      const n = Number(x);
      return Number.isFinite(n) ? n : null;
    }

    function formatPrice(value) {
      if (value == null || Number.isNaN(value)) return "—";
      const v = Number(value);
      if (!Number.isFinite(v)) return "—";
      if (v >= 1000) return "$" + v.toLocaleString("en-US", { maximumFractionDigits: 0 });
      if (v >= 1) return "$" + v.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      if (v >= 0.01) return "$" + v.toLocaleString("en-US", { minimumFractionDigits: 4, maximumFractionDigits: 4 });
      return "$" + v.toLocaleString("en-US", { minimumFractionDigits: 6, maximumFractionDigits: 8 });
    }

    function formatPercent(value) {
      if (value == null || Number.isNaN(value)) return "—";
      const v = Number(value);
      if (!Number.isFinite(v)) return "—";
      const sign = v > 0 ? "+" : "";
      return sign + v.toFixed(2) + "%";
    }

    function formatNumberAbbr(value) {
      if (value == null || Number.isNaN(value)) return "—";
      const v = Number(value);
      if (!Number.isFinite(v)) return "—";
      if (v >= 1e12) return (v / 1e12).toFixed(2) + " T";
      if (v >= 1e9)  return (v / 1e9).toFixed(2) + " B";
      if (v >= 1e6)  return (v / 1e6).toFixed(2) + " M";
      if (v >= 1e3)  return (v / 1e3).toFixed(2) + " K";
      return v.toFixed(0);
    }

    function setSourceBadge(kind, msg) {
      sourceDot.classList.remove("ok", "warn", "bad");
      if (kind === DataSource.BACKEND) sourceDot.classList.add("ok");
      else if (kind === DataSource.COINGECKO) sourceDot.classList.add("warn");
      else if (kind === DataSource.CACHE) sourceDot.classList.add("warn");
      else sourceDot.classList.add("bad");
      sourceText.textContent = msg;
    }

    function escapeHtml(s) {
      const str = String(s ?? "");
      return str
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function showErrorInTable(message) {
      coinsBody.innerHTML = "";
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 7;
      td.style.textAlign = "left";
      td.style.color = "#fca5a5";
      td.textContent = message;
      tr.appendChild(td);
      coinsBody.appendChild(tr);
    }

    function showLoadingRow(message = "Loading…") {
      coinsBody.innerHTML = "";
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 7;
      td.style.textAlign = "left";
      td.style.color = "#9ca3af";
      td.textContent = message;
      tr.appendChild(td);
      coinsBody.appendChild(tr);
    }

    // ==========================================================
    // PREFS
    // ==========================================================
    function loadPrefs() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_PREFS);
        if (!raw) return { tf: "1d", days: 90 };
        const p = JSON.parse(raw);
        return {
          tf: (p && typeof p.tf === "string") ? p.tf : "1d",
          days: (p && Number.isFinite(Number(p.days))) ? Number(p.days) : 90
        };
      } catch {
        return { tf: "1d", days: 90 };
      }
    }

    function savePrefs(tf, days) {
      try {
        localStorage.setItem(STORAGE_KEY_PREFS, JSON.stringify({ tf, days }));
      } catch {}
    }

    // ==========================================================
    // CACHE (markets + charts + ai + news)
    // ==========================================================
    function loadMarketsCache() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_MARKETS);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !Array.isArray(parsed.data) || typeof parsed.ts !== "number") return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function saveMarketsCache(data) {
      try {
        localStorage.setItem(STORAGE_KEY_MARKETS, JSON.stringify({ ts: Date.now(), data }));
      } catch {}
    }

    function isCacheFresh(ts) {
      return (Date.now() - ts) <= MARKETS_CACHE_TTL_MS;
    }

    // NEWS cache helpers
    function loadNewsCache() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_NEWS);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !Array.isArray(parsed.items) || typeof parsed.ts !== "number") return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function saveNewsCache(items) {
      try {
        localStorage.setItem(STORAGE_KEY_NEWS, JSON.stringify({ ts: Date.now(), items }));
      } catch {}
    }

    function isNewsCacheFresh(ts) {
      return (Date.now() - ts) <= NEWS_CACHE_TTL_MS;
    }

    function clearAllCaches() {
      try { localStorage.removeItem(STORAGE_KEY_MARKETS); } catch {}
      try { localStorage.removeItem(STORAGE_KEY_NEWS); } catch {}

      chartCache.clear();
      aiCache.clear();

      coinCommentEl.textContent = "Cache cleared. Select a coin again.";
      scenarioListEl.innerHTML = "<li>—</li>";
      aiHint.textContent = "Cache cleared.";

      // Reset news UI too
      if (newsStatusEl) newsStatusEl.textContent = "News cache cleared. Click Refresh News.";
      if (newsListEl) newsListEl.innerHTML = "";

      if (priceChart) { priceChart.destroy(); priceChart = null; }
    }

    // ==========================================================
    // NET: fetch with status + headers
    // ==========================================================
    async function fetchJsonDetailed(url, {
      timeoutMs = 15000,
      mode = "cors",
      retries = 0,
      retryDelayMs = 900
    } = {}) {
      let lastErr = null;

      for (let attempt = 0; attempt <= retries; attempt++) {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeoutMs);

        try {
          const res = await fetch(url, {
            method: "GET",
            cache: "no-store",
            mode,
            signal: controller.signal,
            headers: { "Accept": "application/json" }
          });

          const contentType = (res.headers.get("content-type") || "").toLowerCase();
          const isJson = contentType.includes("application/json");

          let body = null;
          let text = "";

          if (isJson) body = await res.json().catch(() => null);
          else text = await res.text().catch(() => "");

          if (!res.ok) {
            const msg = isJson ? JSON.stringify(body).slice(0, 260) : (text || "").slice(0, 260);
            const err = new Error(`HTTP ${res.status} ${res.statusText}${msg ? (" - " + msg) : ""}`);
            err.status = res.status;
            err.headers = res.headers;
            err.body = body;
            throw err;
          }

          return { ok: true, status: res.status, headers: res.headers, data: body };
        } catch (err) {
          lastErr = err;
          if (attempt === retries) break;
          const wait = retryDelayMs * Math.pow(1.6, attempt);
          await new Promise(r => setTimeout(r, wait));
        } finally {
          clearTimeout(timer);
        }
      }

      throw lastErr;
    }

    async function fetchJsonWithRetry(url, opts = {}) {
      const res = await fetchJsonDetailed(url, opts);
      return res.data;
    }

    // ==========================================================
    // DATA: build URLs
    // ==========================================================
    function buildMarketsUrlBase(base) {
      const normalized = base.endsWith("/") ? base.slice(0, -1) : base;
      return (
        normalized + BACKEND_MARKETS_ENDPOINT +
        `?vs_currency=usd` +
        `&order=market_cap_desc` +
        `&per_page=50` +
        `&page=1` +
        `&sparkline=false` +
        `&price_change_percentage=1h,24h,7d`
      );
    }

    function buildCoinGeckoMarketsUrl() {
      return (
        API_BASE + "/coins/markets" +
        `?vs_currency=usd` +
        `&order=market_cap_desc` +
        `&per_page=50` +
        `&page=1` +
        `&sparkline=false` +
        `&price_change_percentage=1h,24h,7d`
      );
    }

    function buildAiUrl({ coinId, days = 90, timeframe = "1d" }) {
      const base = BACKEND_BASE_URL.replace(/\/$/, "");
      const qs = new URLSearchParams({
        coin_id: coinId,
        days: String(days),
        timeframe: String(timeframe)
      });
      return `${base}${AI_ENDPOINT}?${qs.toString()}`;
    }

    function buildBackendChartUrl({ coinId, vsCurrency = "usd", days = 30, interval = "daily" }) {
      const base = BACKEND_BASE_URL.replace(/\/$/, "");
      const qs = new URLSearchParams({
        coin_id: coinId,
        vs_currency: vsCurrency,
        days: String(days),
        interval: String(interval)
      });
      return `${base}${CHART_ENDPOINT}?${qs.toString()}`;
    }

    function buildNewsUrl({ limit = 12 } = {}) {
      const base = BACKEND_BASE_URL.replace(/\/$/, "");
      const qs = new URLSearchParams({ limit: String(limit) });
      return `${base}${NEWS_ENDPOINT}?${qs.toString()}`;
    }

    // ==========================================================
    // NEWS: loader + render (backend)
    // Expected backend formats supported:
    //  A) { items: [ { title, url, source, published_at } ] }
    //  B) [ { title, url, source, published_at } ]
    // ==========================================================
    function normalizeNewsPayload(payload) {
      if (Array.isArray(payload)) return payload;
      if (payload && Array.isArray(payload.items)) return payload.items;
      return [];
    }

    function renderNewsItems(items) {
      newsListEl.innerHTML = "";

      if (!items || !items.length) {
        newsStatusEl.textContent = "No news items available right now.";
        return;
      }

      const max = Math.min(items.length, 20);
      for (let i = 0; i < max; i++) {
        const it = items[i] || {};
        const title = String(it.title || it.headline || "Untitled");
        const url = String(it.url || it.link || "");
        const source = String(it.source || it.publisher || "");
        const published = String(it.published_at || it.published || it.date || "");

        const li = document.createElement("li");

        const safeTitle = escapeHtml(title);
        const safeSource = escapeHtml(source);
        const safePublished = escapeHtml(published);

        const meta = [safeSource, safePublished].filter(Boolean).join(" • ");

        if (url && (url.startsWith("http://") || url.startsWith("https://"))) {
          li.innerHTML = `
            <a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="color:#bfdbfe; text-decoration:none;">
              <strong>${safeTitle}</strong>
            </a>
            ${meta ? `<div style="margin-top:2px; color:#9ca3af; font-size:11px;">${meta}</div>` : ""}
          `;
        } else {
          li.innerHTML = `
            <strong>${safeTitle}</strong>
            ${meta ? `<div style="margin-top:2px; color:#9ca3af; font-size:11px;">${meta}</div>` : ""}
          `;
        }

        newsListEl.appendChild(li);
      }

      newsStatusEl.textContent = `Showing ${max} headlines.`;
    }

    async function loadNews({ force = false } = {}) {
      if (!newsListEl || !newsStatusEl || !newsRefreshBtn) return;

      // 1) Use cache if fresh and not forced
      if (!force) {
        const cached = loadNewsCache();
        if (cached && isNewsCacheFresh(cached.ts)) {
          renderNewsItems(cached.items);
          const ageSec = Math.max(0, Math.floor((Date.now() - cached.ts) / 1000));
          newsStatusEl.textContent = `News loaded from cache (${ageSec}s ago).`;
          return;
        }
      }

      // 2) Front-end refresh protection
      const now = Date.now();
      if (!force) {
        const elapsed = now - lastNewsRefreshTs;
        if (elapsed < NEWS_REFRESH_MIN_INTERVAL_MS) {
          const remaining = Math.ceil((NEWS_REFRESH_MIN_INTERVAL_MS - elapsed) / 1000);
          newsStatusEl.textContent = `Please wait ${remaining}s before refreshing news again.`;
          return;
        }
      }
      lastNewsRefreshTs = now;

      // 3) Fetch from backend
      newsRefreshBtn.disabled = true;
      const oldBtnText = newsRefreshBtn.textContent;
      newsRefreshBtn.textContent = "Loading…";

      newsStatusEl.textContent = "Loading news from backend…";

      try {
        const url = buildNewsUrl({ limit: 12 });
        const res = await fetchJsonDetailed(url, { timeoutMs: 20000, retries: 1, retryDelayMs: 1100, mode: "cors" });
        const items = normalizeNewsPayload(res.data);

        // If backend returns something unexpected, treat as empty (but not fatal)
        const normalized = Array.isArray(items) ? items : [];
        saveNewsCache(normalized);
        renderNewsItems(normalized);

      } catch (e) {
        console.error("[News] failed:", e);

        // Fallback to stale cache if exists
        const cached = loadNewsCache();
        if (cached && Array.isArray(cached.items) && cached.items.length) {
          renderNewsItems(cached.items);
          newsStatusEl.textContent = "News backend unavailable. Showing cached headlines.";
        } else {
          newsListEl.innerHTML = "";
          newsStatusEl.textContent = "News backend unavailable. Please try again later.";
        }
      } finally {
        newsRefreshBtn.disabled = false;
        newsRefreshBtn.textContent = oldBtnText;
      }
    }

    // ==========================================================
    // MAIN: markets loader
    // ==========================================================
    async function loadMarkets({ reason = "auto" } = {}) {
      if (isLoadingMarkets) return;
      isLoadingMarkets = true;

      try {
        refreshBtn.disabled = true;
        refreshBtn.textContent = "Loading…";

        dailyInsightEl.textContent = "Loading market analysis...";
        showLoadingRow("Loading…");

        const cached = loadMarketsCache();
        const hasFreshCache = cached && isCacheFresh(cached.ts);

        if (hasFreshCache) {
          coinsRaw = cached.data.filter(Boolean);
          filteredCoins = [...coinsRaw];
          applySort();
          renderTable();
          makeDailyInsight();
          updateTimestamp();
          setSourceBadge(DataSource.CACHE, "Source: cache (last 60s) ✓");
          if (reason !== "manual") return;
        }

        const backendUrl = buildMarketsUrlBase(BACKEND_BASE_URL);
        try {
          const backendRes = await fetchJsonDetailed(backendUrl, { timeoutMs: 15000, retries: 1, retryDelayMs: 1000 });
          const backendData = backendRes.data;
          if (!Array.isArray(backendData)) throw new Error("Backend returned non-array JSON.");
          coinsRaw = backendData.filter(Boolean);
          saveMarketsCache(coinsRaw);
          setSourceBadge(DataSource.BACKEND, `Source: backend proxy ✓ (${BACKEND_BASE_URL})`);
        } catch (errBackend) {
          console.warn("[Markets] backend failed, falling back to CoinGecko direct.", errBackend);
          setSourceBadge(DataSource.COINGECKO, "Source: CoinGecko direct (backend fallback) ⚠");
          const cgUrl = buildCoinGeckoMarketsUrl();
          const cgRes = await fetchJsonDetailed(cgUrl, { timeoutMs: 15000, retries: 1, retryDelayMs: 1200 });
          const cgData = cgRes.data;
          if (!Array.isArray(cgData)) throw new Error("CoinGecko returned non-array JSON.");
          coinsRaw = cgData.filter(Boolean);
          saveMarketsCache(coinsRaw);
        }

        filteredCoins = [...coinsRaw];
        applySort();
        renderTable();
        makeDailyInsight();
        updateTimestamp();

      } catch (err) {
        console.error("[Markets] load failed:", err);
        const cached = loadMarketsCache();
        if (cached && Array.isArray(cached.data) && cached.data.length) {
          coinsRaw = cached.data.filter(Boolean);
          filteredCoins = [...coinsRaw];
          applySort();
          renderTable();
          makeDailyInsight();
          updateTimestamp();
          setSourceBadge(DataSource.CACHE, "Source: cache (fallback after error) ⚠");
          dailyInsightEl.textContent = "Loaded from cache due to upstream error.";
        } else {
          setSourceBadge("error", "Source: FAILED (backend + CoinGecko + no cache)");
          showErrorInTable("Failed to load markets. Please try again in 60s.");
          dailyInsightEl.textContent = "Error loading data (rate limit / backend / network).";
        }
      } finally {
        isLoadingMarkets = false;
        refreshBtn.disabled = false;
        refreshBtn.textContent = "Refresh";
      }
    }

    // ==========================================================
    // SORT / FILTER / TABLE
    // ==========================================================
    function applySort() {
      const key = currentSort;
      filteredCoins.sort((a, b) => {
        if (key === "rank") return (a.market_cap_rank ?? 9999) - (b.market_cap_rank ?? 9999);
        if (key === "change24") return Math.abs(b.price_change_percentage_24h || 0) - Math.abs(a.price_change_percentage_24h || 0);
        if (key === "change1h") return Math.abs(b.price_change_percentage_1h_in_currency || 0) - Math.abs(a.price_change_percentage_1h_in_currency || 0);
        if (key === "change7d") return Math.abs(b.price_change_percentage_7d_in_currency || 0) - Math.abs(a.price_change_percentage_7d_in_currency || 0);
        return 0;
      });
    }

    function renderTable() {
      coinsBody.innerHTML = "";

      if (!filteredCoins.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 7;
        td.style.textAlign = "left";
        td.style.color = "#9ca3af";
        td.textContent = "No data yet. Try Refresh.";
        tr.appendChild(td);
        coinsBody.appendChild(tr);
        return;
      }

      filteredCoins.forEach((coin) => {
        const tr = document.createElement("tr");
        tr.dataset.id = coin.id;

        const rankTd = document.createElement("td");
        rankTd.innerHTML = `<span class="rank">${coin.market_cap_rank ?? "?"}</span>`;
        tr.appendChild(rankTd);

        const nameTd = document.createElement("td");
        nameTd.innerHTML = `
          <div class="coin-name">
            <span>${coin.name ?? "Unknown"}</span>
            <span class="coin-symbol">${(coin.symbol ?? "?").toUpperCase()}</span>
          </div>
        `;
        tr.appendChild(nameTd);

        const priceTd = document.createElement("td");
        priceTd.textContent = formatPrice(coin.current_price);
        tr.appendChild(priceTd);

        const chg1hTd = document.createElement("td");
        const chg1h = coin.price_change_percentage_1h_in_currency;
        chg1hTd.textContent = formatPercent(chg1h);
        chg1hTd.className = chg1h > 0 ? "chg-pos" : chg1h < 0 ? "chg-neg" : "";
        tr.appendChild(chg1hTd);

        const chg24Td = document.createElement("td");
        const chg24 = coin.price_change_percentage_24h;
        chg24Td.textContent = formatPercent(chg24);
        chg24Td.className = chg24 > 0 ? "chg-pos" : chg24 < 0 ? "chg-neg" : "";
        tr.appendChild(chg24Td);

        const chg7dTd = document.createElement("td");
        const chg7d = coin.price_change_percentage_7d_in_currency;
        chg7dTd.textContent = formatPercent(chg7d);
        chg7dTd.className = chg7d > 0 ? "chg-pos" : chg7d < 0 ? "chg-neg" : "";
        tr.appendChild(chg7dTd);

        const mcTd = document.createElement("td");
        mcTd.textContent = "$" + formatNumberAbbr(coin.market_cap ?? 0);
        tr.appendChild(mcTd);

        tr.addEventListener("click", () => handleCoinClick(coin.id));
        coinsBody.appendChild(tr);
      });
    }

    function filterCoins() {
      const q = (searchInput.value || "").toLowerCase().trim();
      if (!q) filteredCoins = [...coinsRaw];
      else {
        filteredCoins = coinsRaw.filter((c) =>
          (c.name || "").toLowerCase().includes(q) ||
          (c.symbol || "").toLowerCase().includes(q)
        );
      }
      applySort();
      renderTable();
    }

    function handleSortChange() {
      currentSort = sortSelect.value;
      applySort();
      renderTable();
    }

    // ==========================================================
    // DAILY INSIGHT (rules)
    // ==========================================================
    function makeDailyInsight() {
      if (!coinsRaw.length) {
        dailyInsightEl.textContent = "Not enough data yet. Try refresh.";
        return;
      }

      let sum24 = 0, count24 = 0;
      let topGainer = null, topLoser = null;
      let highVolMoves = 0;

      coinsRaw.forEach((c) => {
        const chg = c.price_change_percentage_24h;
        if (chg != null && !Number.isNaN(chg)) {
          sum24 += chg;
          count24++;
          if (!topGainer || chg > (topGainer.price_change_percentage_24h ?? -9999)) topGainer = c;
          if (!topLoser || chg < (topLoser.price_change_percentage_24h ?? 9999)) topLoser = c;
          if (Math.abs(chg) >= 5) highVolMoves++;
        }
      });

      const avg24 = count24 ? (sum24 / count24) : 0;
      let mood = "balanced / sideways";
      if (avg24 > 1.5) mood = "bullish";
      else if (avg24 < -1.5) mood = "bearish";

      const volatility =
        highVolMoves >= 10 ? "high (many moves > ±5% in 24h)"
        : highVolMoves >= 4 ? "medium (some strong spikes)"
        : "low (mostly moderate moves)";

      dailyInsightEl.innerHTML = `
        <p>
          Based on <strong>${count24}</strong> top coins by market cap, today’s market mood looks
          <strong>${mood}</strong>, with an average 24h change of <strong>${avg24.toFixed(2)}%</strong>.
        </p>
        <ul class="ai-list">
          <li><strong>Top gainer:</strong> <strong>${topGainer?.name ?? "N/A"}</strong> (${formatPercent(topGainer?.price_change_percentage_24h)} / 24h)</li>
          <li><strong>Top loser:</strong> <strong>${topLoser?.name ?? "N/A"}</strong> (${formatPercent(topLoser?.price_change_percentage_24h)} / 24h)</li>
          <li><strong>Volatility:</strong> <strong>${volatility}</strong></li>
          <li>Educational only, not financial advice.</li>
        </ul>
      `;
    }

    // ==========================================================
    // AI: scenarios (worldwide)
    // ==========================================================
    function computeProbabilisticScenarios({ last, predicted, low, high }) {
      const lastN = safeNum(last);
      const predN = safeNum(predicted);
      const lowN0 = safeNum(low);
      const highN0 = safeNum(high);

      if (lastN == null || predN == null || lowN0 == null || highN0 == null) {
        return [
          { label: "Bullish", prob: 62, from: null, to: null },
          { label: "Bearish", prob: 28, from: null, to: null },
          { label: "Breakout", prob: 10, from: null, to: null }
        ];
      }

      const lowN = Math.min(lowN0, highN0);
      const highN = Math.max(lowN0, highN0);

      const denom = Math.max(1e-9, Math.abs(lastN));
      const widthAbs = Math.max(0, highN - lowN);
      const widthRel = widthAbs / denom;

      const MIN_MOVE_REL = 0.005; // 0.5%
      const minMoveAbs = Math.abs(lastN) * MIN_MOVE_REL;

      const tight = widthRel < 0.04;
      const pMain = tight ? 65 : 62;
      const pAlt  = tight ? 25 : 28;
      const pRare = Math.max(5, 100 - pMain - pAlt);

      const deltaRel = (predN - lastN) / denom;
      const mainIsBull = deltaRel >= 0;

      const mainLabel = mainIsBull ? "Bullish" : "Bearish";
      const altLabel  = mainIsBull ? "Bearish" : "Bullish";
      const rareLabel = mainIsBull ? "Bullish breakout" : "Bearish breakdown";

      const predClamped = Math.min(highN, Math.max(lowN, predN));
      const intervalCanSupportMove = widthAbs >= (minMoveAbs * 0.9);

      let mainTo = null;
      if (intervalCanSupportMove) {
        if (mainIsBull) {
          const candidate = Math.max(predClamped, lastN + minMoveAbs);
          mainTo = Math.min(highN, candidate);
          if (!(mainTo > lastN)) mainTo = null;
        } else {
          const candidate = Math.min(predClamped, lastN - minMoveAbs);
          mainTo = Math.max(lowN, candidate);
          if (!(mainTo < lastN)) mainTo = null;
        }
      }

      let altTo = null;
      if (intervalCanSupportMove) {
        if (mainIsBull) {
          const candidate = Math.min(predClamped, lastN - minMoveAbs);
          altTo = Math.max(lowN, candidate);
          if (!(altTo < lastN)) altTo = null;
        } else {
          const candidate = Math.max(predClamped, lastN + minMoveAbs);
          altTo = Math.min(highN, candidate);
          if (!(altTo > lastN)) altTo = null;
        }
      }

      const OUT_REL = 0.006;
      const OUT_MIN = 0.002;
      let rareTo;
      if (mainIsBull) {
        rareTo = Math.max(highN * (1 + OUT_REL), highN * (1 + OUT_MIN));
      } else {
        rareTo = Math.min(lowN * (1 - OUT_REL), lowN * (1 - OUT_MIN));
      }

      return [
        { label: mainLabel, prob: pMain, from: lastN, to: mainTo },
        { label: altLabel,  prob: pAlt,  from: lastN, to: altTo },
        { label: rareLabel, prob: pRare, from: lastN, to: rareTo }
      ];
    }

    function renderProbabilisticScenarioList(scenarios) {
      scenarioListEl.innerHTML = "";

      if (!Array.isArray(scenarios) || scenarios.length === 0) {
        scenarioListEl.innerHTML = "<li>No scenarios available.</li>";
        return;
      }

      for (const s of scenarios) {
        const li = document.createElement("li");

        const label =
          (s && typeof s.label === "string" && s.label.trim()) ? s.label : "Scenario";

        const probNum = Number(s?.prob);
        const probTxt = Number.isFinite(probNum) ? `${probNum.toFixed(0)}%` : "—";

        const fromTxt = (s?.from == null) ? "—" : formatPrice(s.from);
        const toTxt   = (s?.to == null) ? "—" : formatPrice(s.to);

        li.innerHTML = `
          <div>
            <strong>${label} (${probTxt})</strong>
            &nbsp;from&nbsp;<strong>${fromTxt}</strong>
            &nbsp;→&nbsp;<strong>${toTxt}</strong>
          </div>
        `;
        scenarioListEl.appendChild(li);
      }
    }

    // ==========================================================
    // AI: rate-limit UX (429) + retry
    // ==========================================================
    function stopAiRetryTimer() {
      if (aiRetryTimer) clearInterval(aiRetryTimer);
      aiRetryTimer = null;
      aiRetryRemainingSec = 0;
    }

    function startAiRetryCountdown(seconds) {
      stopAiRetryTimer();
      aiRetryRemainingSec = Math.max(1, Math.floor(seconds || 10));
      btnRetryAi.disabled = true;

      aiHint.textContent = `AI rate-limited. Retry available in ${aiRetryRemainingSec}s.`;

      aiRetryTimer = setInterval(() => {
        aiRetryRemainingSec -= 1;
        if (aiRetryRemainingSec <= 0) {
          stopAiRetryTimer();
          btnRetryAi.disabled = false;
          aiHint.textContent = "AI retry is available now.";
          return;
        }
        aiHint.textContent = `AI rate-limited. Retry available in ${aiRetryRemainingSec}s.`;
      }, 1000);
    }

    async function fetchAiPredictionForCoin(coinId, { days = 90, timeframe = "1d" } = {}) {
      const now = Date.now();

      if (!forceAiRefresh) {
        const cached = aiCache.get(coinId);
        if (cached && (now - cached.ts) <= AI_CACHE_TTL_MS) {
          return cached.data;
        }
      }

      const url = buildAiUrl({ coinId, days, timeframe });

      try {
        const res = await fetchJsonDetailed(url, { timeoutMs: 45000, retries: 0, mode: "cors" });
        const data = res.data;

        aiCache.set(coinId, { ts: now, data });
        return data;

      } catch (err) {
        const status = err && err.status;

        const cached = aiCache.get(coinId);
        if (status === 429 && cached && cached.data) {
          return cached.data;
        }

        await new Promise(r => setTimeout(r, 1200));

        const res2 = await fetchJsonDetailed(url, { timeoutMs: 45000, retries: 0, mode: "cors" });
        const data2 = res2.data;

        aiCache.set(coinId, { ts: Date.now(), data: data2 });
        return data2;

      } finally {
        forceAiRefresh = false;
      }
    }

    // ==========================================================
    // CHART (backend-only, daily, 30d)
    // ==========================================================
    function yTickFormatter(v) {
      const n = Number(v);
      if (!Number.isFinite(n)) return "";
      if (Math.abs(n) >= 1000) return "$" + n.toFixed(0);
      if (Math.abs(n) >= 1) return "$" + n.toFixed(2);
      if (Math.abs(n) >= 0.01) return "$" + n.toFixed(4);
      return "$" + n.toFixed(6);
    }

    async function loadChartForCoin(coin) {
      const id = coin.id;

      let chartData = chartCache.get(id);
      if (!chartData) {
        const backendUrl = buildBackendChartUrl({
          coinId: id,
          vsCurrency: "usd",
          days: 30,
          interval: "daily"
        });

        const payload = await fetchJsonWithRetry(backendUrl, { timeoutMs: 18000, retries: 0, mode: "cors" });
        const prices = Array.isArray(payload?.prices) ? payload.prices : [];
        if (!prices.length) throw new Error("Backend chart returned empty prices.");

        chartData = normalizeChartPrices(prices);
        chartCache.set(id, chartData);
      }

      const canvas = document.getElementById("priceChart");
      const ctx = canvas.getContext("2d");
      if (priceChart) priceChart.destroy();

      priceChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: chartData.labels,
          datasets: [{
            label: `${coin.name} – price (USD)`,
            data: chartData.values,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.25
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { labels: { color: "#e5e7eb", font: { size: 10 } } } },
          scales: {
            x: { ticks: { color: "#9ca3af", maxRotation: 0, autoSkip: true, autoSkipPadding: 16 }, grid: { display: false } },
            y: { ticks: { color: "#9ca3af", callback: (v) => yTickFormatter(v) }, grid: { color: "rgba(55, 65, 81, 0.6)" } }
          }
        }
      });
    }

    function normalizeChartPrices(prices) {
      const labels = [];
      const values = [];
      const step = Math.max(1, Math.floor(prices.length / 80));

      for (let i = 0; i < prices.length; i += step) {
        const row = prices[i];
        if (!Array.isArray(row) || row.length < 2) continue;

        const ts = row[0];
        const pn = safeNum(row[1]);
        if (pn == null) continue;

        const d = new Date(ts);
        labels.push(
          d.toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit" }) + " " +
          d.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" })
        );
        values.push(pn);
      }
      return { labels, values };
    }

    // ==========================================================
    // SELECT COIN: chart + AI
    // ==========================================================
    async function handleCoinClick(id) {
      const coin = coinsRaw.find((c) => c.id === id);
      if (!coin) return;

      selectedCoinId = id;
      btnRetryAi.disabled = true;
      stopAiRetryTimer();

      selectedNameEl.textContent = coin.name ?? "Unknown";
      selectedSymbolEl.textContent = (coin.symbol ?? "?").toUpperCase() + " / USD";
      selectedPriceEl.textContent = formatPrice(coin.current_price);
      metricMarketCapEl.textContent = "$" + formatNumberAbbr(coin.market_cap ?? 0);

      selectedPillsEl.innerHTML = "";

      const pill24 = document.createElement("span");
      pill24.className = "pill-info " + ((coin.price_change_percentage_24h ?? 0) > 0 ? "green" : (coin.price_change_percentage_24h ?? 0) < 0 ? "red" : "");
      pill24.textContent = "24h: " + formatPercent(coin.price_change_percentage_24h);
      selectedPillsEl.appendChild(pill24);

      const pill1h = document.createElement("span");
      pill1h.className = "pill-info " + ((coin.price_change_percentage_1h_in_currency ?? 0) > 0 ? "green" : (coin.price_change_percentage_1h_in_currency ?? 0) < 0 ? "red" : "");
      pill1h.textContent = "1h: " + formatPercent(coin.price_change_percentage_1h_in_currency);
      selectedPillsEl.appendChild(pill1h);

      const pill7d = document.createElement("span");
      pill7d.className = "pill-info " + ((coin.price_change_percentage_7d_in_currency ?? 0) > 0 ? "green" : (coin.price_change_percentage_7d_in_currency ?? 0) < 0 ? "red" : "");
      pill7d.textContent = "7d: " + formatPercent(coin.price_change_percentage_7d_in_currency);
      selectedPillsEl.appendChild(pill7d);

      try {
        coinCommentEl.textContent = "Loading chart from backend…";
        await loadChartForCoin(coin);
      } catch (e) {
        console.error("[Chart] failed:", e);
        coinCommentEl.textContent = "Chart unavailable (backend rate-limit or network). Please retry later.";
        if (priceChart) { priceChart.destroy(); priceChart = null; }
      }

      metricBiasEl.textContent = "Loading AI…";
      coinCommentEl.textContent = "Fetching AI prediction from backend…";
      scenarioListEl.innerHTML = "<li>Loading scenarios…</li>";
      aiHint.textContent = "AI request in progress…";

      const tf = (tfSelect.value || "1d");
      const days = Number(daysSelect.value || 90);
      savePrefs(tf, days);

      try {
        const ai = await fetchAiPredictionForCoin(coin.id, { days, timeframe: tf });

        const last = safeNum(ai?.last_price);
        const predicted = safeNum(ai?.predicted_price);
        const low = safeNum(ai?.prediction_interval_68?.low);
        const high = safeNum(ai?.prediction_interval_68?.high);
        const rsi = safeNum(ai?.indicators?.rsi);

        const scenarios = computeProbabilisticScenarios({ last, predicted, low, high });
        renderProbabilisticScenarioList(scenarios);

        const model = ai?.model || "ai";
        metricBiasEl.textContent = `${model} • RSI ${rsi != null ? rsi.toFixed(2) : "—"}`;

        if (last != null && predicted != null && low != null && high != null) {
          coinCommentEl.textContent =
            `Prediction: ${formatPrice(predicted)} (68% range: ${formatPrice(low)} – ${formatPrice(high)}).`;
          aiHint.textContent = `AI OK • TF ${tf} • History ${days}d`;
        } else {
          coinCommentEl.textContent =
            "Prediction returned, but some fields are missing (check backend response).";
          aiHint.textContent = "AI responded, but some values were missing.";
        }

      } catch (e) {
        console.error("[AI] failed:", e);

        const status = e && e.status;
        if (status === 429) {
          let retryAfter = 15;
          try {
            const ra = e.headers && e.headers.get && e.headers.get("Retry-After");
            const raNum = Number(ra);
            if (Number.isFinite(raNum) && raNum > 0) retryAfter = raNum;
          } catch {}

          metricBiasEl.textContent = "AI rate-limited";
          coinCommentEl.textContent = "AI rate-limited by upstream. Please retry shortly.";
          scenarioListEl.innerHTML = "<li>AI rate-limited. Retry shortly.</li>";
          startAiRetryCountdown(retryAfter);
          return;
        }

        metricBiasEl.textContent = "AI unavailable";
        coinCommentEl.textContent = "AI endpoint failed. Please try again later.";
        scenarioListEl.innerHTML = "<li>AI is temporarily unavailable.</li>";
        aiHint.textContent = "AI unavailable (network/backend).";
        btnRetryAi.disabled = false;
      }
    }

    async function retryAiForSelectedCoin() {
      if (!selectedCoinId) return;
      forceAiRefresh = true;
      await handleCoinClick(selectedCoinId);
    }

    // ==========================================================
    // BACKEND TESTS
    // ==========================================================
    async function testHealth() {
      const url = `${BACKEND_BASE_URL.replace(/\/$/, "")}/health`;
      aiResult.textContent = "Calling: " + url;
      btnHealth.disabled = true;
      try {
        const res = await fetchJsonDetailed(url, { timeoutMs: 12000, retries: 0, mode: "cors" });
        aiResult.textContent = JSON.stringify(res.data, null, 2);
      } catch (err) {
        aiResult.textContent = "Health error:\n" + String(err);
      } finally {
        btnHealth.disabled = false;
      }
    }

    async function handleAiBackendTest() {
      const coinId = (aiInput.value || "bitcoin").trim();
      if (!coinId) { aiResult.textContent = "Please enter a CoinGecko coin id."; return; }

      const tf = (tfSelect.value || "1d");
      const days = Number(daysSelect.value || 90);

      const url = buildAiUrl({ coinId, days, timeframe: tf });
      aiResult.textContent = "Calling: " + url;
      btnTestBackend.disabled = true;

      try {
        const res = await fetchJsonDetailed(url, { timeoutMs: 45000, retries: 0, mode: "cors" });
        const data = res.data;

        document.getElementById("ai-summary-coin").textContent = data?.coin_id ?? "-";
        document.getElementById("ai-summary-last").textContent =
          (typeof data?.last_price === "number") ? data.last_price.toFixed(6) : "-";
        document.getElementById("ai-summary-predicted").textContent =
          (typeof data?.predicted_price === "number") ? data.predicted_price.toFixed(6) : "-";
        document.getElementById("ai-summary-rsi").textContent =
          (typeof data?.indicators?.rsi === "number") ? data.indicators.rsi.toFixed(2) : "-";

        aiResult.textContent = JSON.stringify(data, null, 2);
      } catch (err) {
        aiResult.textContent = "Error while calling backend:\n" + String(err);
      } finally {
        btnTestBackend.disabled = false;
      }
    }

    // ==========================================================
    // EVENTS + INIT
    // ==========================================================
    searchInput.addEventListener("input", filterCoins);
    sortSelect.addEventListener("change", handleSortChange);

    refreshBtn.addEventListener("click", async () => {
      const now = Date.now();
      const elapsed = now - lastManualRefreshTs;

      if (elapsed < REFRESH_MIN_INTERVAL_MS) {
        const remaining = Math.ceil((REFRESH_MIN_INTERVAL_MS - elapsed) / 1000);
        alert(`Please wait ${remaining}s before refreshing again (rate-limit protection).`);
        return;
      }

      lastManualRefreshTs = now;
      await loadMarkets({ reason: "manual" });
    });

    // NEWS refresh button
    newsRefreshBtn.addEventListener("click", async () => {
      await loadNews({ force: true });
    });

    btnTestBackend.addEventListener("click", handleAiBackendTest);
    btnHealth.addEventListener("click", testHealth);

    btnRetryAi.addEventListener("click", async () => {
      btnRetryAi.disabled = true;
      stopAiRetryTimer();
      aiHint.textContent = "Retrying AI…";
      await retryAiForSelectedCoin();
    });

    btnClearCache.addEventListener("click", () => {
      clearAllCaches();
    });

    tfSelect.addEventListener("change", () => {
      const days = Number(daysSelect.value || 90);
      savePrefs(tfSelect.value, days);
      if (selectedCoinId) {
        aiHint.textContent = "Timeframe changed. Click Retry AI to refresh scenarios.";
        btnRetryAi.disabled = false;
      }
    });

    daysSelect.addEventListener("change", () => {
      const days = Number(daysSelect.value || 90);
      savePrefs(tfSelect.value, days);
      if (selectedCoinId) {
        aiHint.textContent = "History changed. Click Retry AI to refresh scenarios.";
        btnRetryAi.disabled = false;
      }
    });

    document.addEventListener("DOMContentLoaded", () => {
      setSourceBadge("init", "Source: checking…");

      const prefs = loadPrefs();
      if (prefs && prefs.tf) tfSelect.value = prefs.tf;
      if (prefs && Number.isFinite(Number(prefs.days))) daysSelect.value = String(prefs.days);

      // Load markets + news
      loadMarkets({ reason: "auto" });
      loadNews({ force: false });
    });
  </script>
</body>
</html>
