<!DOCTYPE html>
<html lang="en">
<head>
  <!-- AdSense loader (keep if you already use it) -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9902358545401183"
    crossorigin="anonymous"></script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CryptoVision – AI Crypto Insights</title>
  <meta name="description" content="CryptoVision – live crypto prices + AI insights. Backend proxy + fallback." />
  <meta name="theme-color" content="#020617" />

  <!-- Chart.js (defer to avoid blocking render) -->
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --bg:#050816;
      --bg2:#081026;
      --accent:#22c55e;
      --accent-soft:rgba(34,197,94,.15);
      --danger:#f97373;
      --danger-soft:rgba(248,113,113,.15);
      --warning:#eab308;
      --text:#e5e7eb;
      --text-soft:#9ca3af;
      --border:#1f2937;
      --card:#0f172a;
      --card-soft:rgba(15,23,42,.9);
      --shadow:0 22px 60px rgba(0,0,0,.55);
      --font:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}

    body{
      min-height:100vh;
      font-family:var(--font);
      color:var(--text);
      margin:0;
      padding:24px 12px;
      overflow-x:hidden;
      overflow-y:auto;

      /* Background image + dark overlay */
      background-image:
        linear-gradient(rgba(2,6,23,0.55), rgba(2,6,23,0.55)),
        url("/assets/cryptovision-hero.png");
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
      background-attachment:fixed;
      background-color:#020617;
    }

    .shell{
      width:100%;
      max-width:1720px;
      margin:0 auto;

      /* semi-transparent container so background image stays visible */
      background:rgba(2,6,23,0.55);

      border-radius:32px;
      box-shadow:var(--shadow);
      padding:24px 24px 28px;
      border:1px solid rgba(148,163,184,.25);
      position:relative;
      overflow:hidden;

      /* glass effect */
      backdrop-filter: blur(14px);
    }

    /* Top bar */
    .top-bar{
      display:flex; justify-content:space-between; gap:16px;
      align-items:center; margin-bottom:18px; flex-wrap:wrap;
    }
    .logo-wrap{display:flex; align-items:center; gap:14px}

    /* Logo badge (clickable premium) */
    .logo-badge{
      width:44px;height:44px;border-radius:999px;
      background:rgba(15,23,42,.65);
      border:1px solid rgba(148,163,184,.35);
      display:flex;align-items:center;justify-content:center;
      overflow:hidden;
      box-shadow:0 0 0 1px rgba(15,23,42,.35), 0 14px 30px rgba(0,0,0,.45);
      flex:0 0 auto;
    }
    a.logo-badge{ text-decoration:none; position:relative; }
    .logo-badge img{ width:100%; height:100%; object-fit:cover; display:block; }
    .logo-badge:hover{ filter:brightness(1.06); }

    .logo-upgrade{
      position:absolute;
      left:50%;
      bottom:-9px;
      transform:translateX(-50%);
      font-size:10px;
      padding:2px 7px;
      border-radius:999px;
      background:rgba(37,99,235,.25);
      border:1px solid rgba(96,165,250,.55);
      color:#bfdbfe;
      white-space:nowrap;
      backdrop-filter:blur(10px);
      pointer-events:none;
    }

    .title-block h1{
      font-size:22px; letter-spacing:.03em;
      display:flex; align-items:center; gap:8px;
    }
    .title-pill{
      font-size:11px; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(96,165,250,.7);
      color:#bfdbfe;
      background:linear-gradient(135deg,rgba(37,99,235,.45),rgba(56,189,248,.1));
      text-transform:uppercase;
    }
    .title-block p{font-size:13px;color:var(--text-soft);margin-top:3px}

    .status-wrap{display:flex; flex-direction:column; align-items:flex-end; gap:6px; font-size:12px}
    .live-badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 10px; border-radius:999px;
      background:rgba(22,163,74,.12); color:#bbf7d0;
      border:1px solid rgba(34,197,94,.6);
      font-size:11px; text-transform:uppercase; letter-spacing:.08em;
    }
    .dot{width:8px;height:8px;border-radius:999px;background:#22c55e;box-shadow:0 0 0 4px rgba(34,197,94,.3)}
    .updated-at{font-size:12px;color:var(--text-soft)}
    .source-badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(148,163,184,.35);
      background:rgba(15,23,42,.6);
      color:#cbd5e1; font-size:11px;
      max-width:100%;
    }
    .source-dot{
      width:8px;height:8px;border-radius:999px; background:#60a5fa;
      box-shadow:0 0 0 4px rgba(96,165,250,.18);
      flex:0 0 auto;
    }
    .source-dot.ok{background:#22c55e; box-shadow:0 0 0 4px rgba(34,197,94,.18);}
    .source-dot.warn{background:#eab308; box-shadow:0 0 0 4px rgba(234,179,8,.18);}
    .source-dot.bad{background:#f97373; box-shadow:0 0 0 4px rgba(249,115,115,.18);}
    .source-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}

    /* Pricing pill + usage */
    .right-actions{display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
    .pill-btn{
      border-radius:999px;
      border:1px solid rgba(148,163,184,.35);
      background:rgba(15,23,42,.75);
      color:#e5e7eb;
      font-size:11px;
      padding:7px 10px;
      cursor:pointer;
      display:inline-flex;
      gap:8px;
      align-items:center;
      backdrop-filter:blur(16px);
      white-space:nowrap;
    }
    .pill-btn:hover{filter:brightness(1.06)}
    .pill-btn.primary{
      background:linear-gradient(135deg, rgba(37,99,235,.55), rgba(34,197,94,.25));
      border-color:rgba(96,165,250,.55);
      color:#e0f2fe;
    }
    .usage-pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.35);
      background:rgba(15,23,42,.6);
      color:#cbd5e1;
      font-size:11px;
      max-width:100%;
    }

    /* Top info */
    .grid-top{
      display:grid; grid-template-columns:minmax(0,3fr) minmax(0,2fr);
      gap:18px; margin-bottom:16px;
    }
    .pill-row{display:flex; flex-wrap:wrap; gap:10px}
    .feature-pill{
      display:flex; align-items:center; gap:6px;
      padding:7px 10px; border-radius:999px; font-size:11px;
      background:rgba(15,23,42,.8);
      border:1px solid rgba(148,163,184,.35);
      backdrop-filter:blur(16px);
    }
    .feature-pill span.icon{
      width:16px;height:16px;border-radius:999px;
      display:inline-flex; align-items:center; justify-content:center;
      font-size:11px;
    }
    .feature-pill.good span.icon{background:rgba(34,197,94,.18);color:#bbf7d0}
    .feature-pill.info span.icon{background:rgba(59,130,246,.18);color:#bfdbfe}
    .feature-pill.ad span.icon{background:rgba(234,179,8,.18);color:#fef9c3}
    .mini-note{font-size:11px;color:#9ca3af;margin-top:6px}

    .top-info-card{
      padding:10px 14px; border-radius:18px;
      background:rgba(15,23,42,.88);
      border:1px solid rgba(148,163,184,.35);
      backdrop-filter:blur(16px); font-size:12px;
    }
    .top-info-card strong{color:#e5e7eb}

    /* Main grid */
    .main-grid{
      display:grid;
      grid-template-columns:minmax(0,4fr) minmax(0,2fr);
      gap:18px;
      align-items:start;
    }

    .card{
      background:var(--card-soft);
      border-radius:22px;
      padding:14px 14px 16px;
      border:1px solid rgba(148,163,184,.3);
      box-shadow:0 18px 45px rgba(15,23,42,.9);
      backdrop-filter:blur(18px);
      position:relative; overflow:hidden;
    }

    .card-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:10px}
    .card-title{font-size:14px;font-weight:600}
    .card-subtitle{font-size:11px;color:var(--text-soft)}
    .badge{
      padding:3px 8px; border-radius:999px;
      font-size:10px; letter-spacing:.06em; text-transform:uppercase;
      border:1px solid rgba(148,163,184,.5); color:#e5e7eb;
    }
    .badge.green{border-color:rgba(34,197,94,.7);background:rgba(22,163,74,.12);color:#bbf7d0}
    .badge.blue{border-color:rgba(59,130,246,.7);background:rgba(37,99,235,.18);color:#bfdbfe}
    .badge.orange{border-color:rgba(234,179,8,.7);background:rgba(234,179,8,.16);color:#fef3c7}
    .badge.gray{border-color:rgba(148,163,184,.35);background:rgba(15,23,42,.5);color:#e5e7eb}

    .toolbar{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px;align-items:center;font-size:12px}
    .search-box{flex:1}
    .search-input{
      width:100%; padding:7px 9px; border-radius:999px;
      border:1px solid rgba(148,163,184,.35);
      background:rgba(15,23,42,.9); color:var(--text);
      font-size:12px; outline:none;
    }
    .search-input::placeholder{color:#6b7280}
    .select-small,.btn-small{
      border-radius:999px; border:1px solid rgba(148,163,184,.4);
      background:rgba(15,23,42,.9); color:var(--text-soft);
      font-size:11px; padding:6px 9px; outline:none; cursor:pointer;
    }
    .btn-small.primary{
      background:linear-gradient(to right,#2563eb,#22c55e);
      border-color:transparent; color:#ecfeff; font-weight:500;
    }
    .btn-small.secondary{
      background:rgba(15,23,42,.92);
      border:1px solid rgba(96,165,250,.6);
      color:#bfdbfe;
    }
    .btn-small.danger{
      background:rgba(248,113,113,.12);
      border:1px solid rgba(248,113,113,.65);
      color:#fecaca;
    }
    .btn-small[disabled]{opacity:.55; cursor:not-allowed; filter:none;}

    .table-wrap{
      max-height:420px; overflow:auto; border-radius:16px;
      border:1px solid rgba(31,41,55,.9);
      background:radial-gradient(circle at top, rgba(15,23,42,.96), #020617);
    }
    table{width:100%; border-collapse:collapse; font-size:12px}
    thead{
      background:rgba(15,23,42,.95);
      position:sticky; top:0; z-index:2;
    }
    th,td{
      padding:7px 10px; text-align:right;
      border-bottom:1px solid rgba(31,41,55,.9);
      white-space:nowrap;
    }
    th:first-child,td:first-child{text-align:left}
    th:nth-child(2),td:nth-child(2){text-align:left}
    th{
      font-size:11px; color:#9ca3af;
      text-transform:uppercase; letter-spacing:.06em;
    }
    tbody tr{cursor:pointer; transition:background .15s ease-out}
    tbody tr:nth-child(even){background:rgba(15,23,42,.85)}
    tbody tr:hover{background:rgba(37,99,235,.18)}
    .rank{color:#6b7280;font-size:11px}
    .coin-name{display:flex; align-items:center; gap:6px}
    .coin-symbol{
      font-size:10px; text-transform:uppercase; color:#9ca3af;
      padding:1px 5px; border-radius:999px;
      background:rgba(15,23,42,.9);
      border:1px solid rgba(55,65,81,.9);
    }
    .chg-pos{color:#22c55e}
    .chg-neg{color:#f97373}

    .ai-text{font-size:12px; line-height:1.55; color:#e5e7eb}
    .ai-text strong{color:#bfdbfe}
    .ai-list{margin-top:8px; list-style:none; font-size:12px; color:#cbd5f5}
    .ai-list li{margin-bottom:4px; position:relative; padding-left:14px}
    .ai-list li::before{content:"•"; position:absolute; left:2px; color:#60a5fa}

    .small-label{font-size:11px; color:#9ca3af; margin-bottom:4px}
    .pair-header{display:flex; justify-content:space-between; align-items:baseline; margin-bottom:4px; gap:4px; flex-wrap:wrap}
    .pair-name{font-size:14px; font-weight:600}
    .pair-symbol{font-size:11px; text-transform:uppercase; color:#9ca3af}
    .big-price{font-size:20px; font-weight:600}

    .pill-row-small{display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 10px; font-size:11px}
    .pill-info{
      padding:3px 7px; border-radius:999px;
      border:1px solid rgba(148,163,184,.45);
      color:#e5e7eb; background:rgba(15,23,42,.9);
    }
    .pill-info.green{border-color:rgba(34,197,94,.7); background:var(--accent-soft); color:#bbf7d0}
    .pill-info.red{border-color:rgba(248,113,113,.75); background:var(--danger-soft); color:#fecaca}

    .metric-grid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px; font-size:11px; margin-bottom:10px}
    .metric-item{
      padding:6px 8px; border-radius:12px;
      background:rgba(15,23,42,.9);
      border:1px solid rgba(30,64,175,.8);
    }
    .metric-label{color:#9ca3af; margin-bottom:2px}
    .metric-value{font-weight:600}
    .metric-note{font-size:10px; color:#9ca3af; margin-top:2px}

    .ai-comment{
      margin-top:2px;
      padding:7px 9px;
      border-radius:12px;
      background:rgba(15,23,42,.9);
      border:1px dashed rgba(148,163,184,.7);
      font-size:12px; line-height:1.5;
      color:#e5e7eb;
    }

    .scenario-block{margin-top:8px; font-size:11px}
    .scenario-block strong{color:#bfdbfe}
    .scenario-list{list-style:none; margin-top:6px}
    .scenario-list li{margin-bottom:8px; line-height:1.35}

    .chart-wrap{
      margin-top:10px;
      background:radial-gradient(circle at top, rgba(30,64,175,.4), #020617);
      border-radius:14px;
      padding:8px 8px 4px;
      border:1px solid rgba(30,64,175,.8);
    }
    .chart-wrap canvas{width:100%; height:210px; max-height:210px}

    .ad-card{
      margin-top:12px;
      padding:10px 12px;
      border-radius:16px;
      border:1px dashed rgba(234,179,8,.7);
      background:rgba(24,16,3,.8);
      font-size:11px; color:#fef9c3;
    }
    .ad-card strong{color:#facc15}

    .footer-note{margin-top:10px; font-size:10px; color:#6b7280; text-align:right}

    .backend-grid{
      display:grid;
      grid-template-columns:minmax(0,1fr) minmax(0,1fr);
      gap:12px;
      margin-top:16px;
    }
    .panel{
      border-radius:18px;
      border:1px solid rgba(148,163,184,.25);
      background:rgba(15,23,42,.75);
      padding:14px;
    }
    .panel h2,.panel h3{font-size:14px; margin-bottom:8px}
    .panel p{font-size:12px; color:var(--text-soft); line-height:1.5}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:10px 0}
    .input{
      padding:7px 10px; border-radius:10px;
      border:1px solid rgba(148,163,184,.35);
      background:#020617; color:#f9fafb;
      min-width:180px; outline:none;
    }
    .btn{
      padding:7px 14px; border-radius:999px;
      border:none; background:#22c55e; color:#020617;
      font-weight:800; cursor:pointer;
    }
    .btn:hover{filter:brightness(1.05)}
    .btn[disabled]{opacity:.55; cursor:not-allowed; filter:none;}
    pre{
      max-height:260px; overflow:auto;
      background:#020617; border-radius:12px;
      padding:10px; font-size:12px;
      border:1px solid #1f2937; color:#e5e7eb;
      white-space:pre-wrap;
    }

    .controls-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin:8px 0 10px;
    }
    .controls-row .select-small{color:#e5e7eb}
    .hint{
      font-size:11px;
      color:var(--text-soft);
      margin-top:6px;
      line-height:1.4;
    }

    /* Promo cards */
    .promo-card{ padding:0; overflow:hidden; cursor:pointer; position:relative; border:1px solid rgba(148,163,184,.28); }
    .promo-link{ display:block; text-decoration:none; color:inherit; position:relative; border-radius:22px; overflow:hidden; }
    .promo-img{ display:block; width:100%; height:auto; transform:scale(1); transition:transform .25s ease; filter:saturate(1.05); }
    .promo-overlay{
      position:absolute; inset:0;
      background:linear-gradient(90deg, rgba(2,6,23,0.78) 0%, rgba(2,6,23,0.35) 50%, rgba(2,6,23,0.75) 100%);
      pointer-events:none;
    }
    .promo-cta{
      position:absolute; left:14px; bottom:12px;
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      font-size:11px; letter-spacing:.02em;
      border:1px solid rgba(96,165,250,.55);
      background:rgba(15,23,42,.78);
      backdrop-filter:blur(10px);
      color:#e5e7eb;
    }
    .promo-cta strong{color:#bfdbfe}
    .promo-card:hover .promo-img{transform:scale(1.015); filter:saturate(1.12) brightness(1.02)}

    /* Modal */
    .modal-backdrop{
      position:fixed; inset:0;
      background:rgba(2,6,23,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:50;
    }
    .modal-backdrop.show{display:flex}
    .modal{
      width:min(920px, 100%);
      border-radius:22px;
      border:1px solid rgba(148,163,184,.28);
      background:rgba(15,23,42,.92);
      box-shadow:0 22px 70px rgba(0,0,0,.65);
      overflow:hidden;
    }
    .modal-head{
      display:flex; justify-content:space-between; align-items:center;
      padding:14px 16px;
      border-bottom:1px solid rgba(148,163,184,.18);
    }
    .modal-head h3{font-size:14px}
    .modal-close{
      border:1px solid rgba(148,163,184,.25);
      background:rgba(2,6,23,.35);
      color:#e5e7eb;
      border-radius:12px;
      padding:6px 10px;
      cursor:pointer;
    }
    .modal-body{padding:14px 16px}
    .plan-grid{
      display:grid;
      grid-template-columns:repeat(3, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }
    .plan{
      border-radius:18px;
      border:1px solid rgba(148,163,184,.25);
      background:rgba(2,6,23,.35);
      padding:12px;
      position:relative;
    }
    .plan .tag{
      position:absolute; top:10px; right:10px;
      font-size:10px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.25);
      color:#e5e7eb;
      background:rgba(15,23,42,.55);
    }
    .plan h4{font-size:13px;margin-bottom:6px}
    .plan .price{font-size:18px; font-weight:700; margin-bottom:6px}
    .plan .desc{font-size:11px;color:var(--text-soft);line-height:1.45}
    .plan ul{list-style:none;margin-top:10px;font-size:11px;color:#cbd5e1}
    .plan li{margin-bottom:6px; position:relative; padding-left:14px}
    .plan li::before{content:"•"; position:absolute; left:2px; color:#60a5fa}
    .plan .actions{margin-top:12px; display:flex; gap:8px; flex-wrap:wrap}
    .plan .btn-small{flex:1}
    .plan .btn-small.primary{color:#ecfeff}

    .note{
      margin-top:10px;
      font-size:11px;
      color:var(--text-soft);
      line-height:1.45;
    }

    @media (max-width: 980px){
      .grid-top,.main-grid,.backend-grid{grid-template-columns:minmax(0,1fr)}
      .status-wrap{align-items:flex-start}
      .table-wrap{max-height:360px}
      .plan-grid{grid-template-columns:minmax(0,1fr)}
    }
  </style>
</head>

<body>
  <div class="shell">
    <header class="top-bar">
      <div class="logo-wrap">
        <!-- PREMIUM LOGO (clickable) -->
        <a href="premium.html" class="logo-badge" title="Premium">
          <img src="assets/logo.png" alt="CryptoVision logo" loading="eager"
               onerror="this.onerror=null; this.src='assets/cryptovision-hero.png';" />
          <span class="logo-upgrade">Premium</span>
        </a>

        <div class="title-block">
          <h1>CryptoVision <span class="title-pill">AI Crypto Insights</span></h1>
          <p>Live crypto prices + AI insights. (Backend proxy + fallback)</p>
        </div>
      </div>

      <div class="status-wrap">
        <div class="right-actions">
          <div class="usage-pill" id="usagePill">Plan: — • Usage: —</div>
          <button class="pill-btn primary" id="btnOpenPricing" type="button" title="Plans & pricing">
            Plans • Pricing
          </button>
          <a class="pill-btn" href="premium.html" title="Premium page">Premium page</a>
        </div>

        <div class="live-badge"><span class="dot"></span><span>Live market feed (real-time-ish)</span></div>
        <div class="updated-at" id="updatedAtText">Updated: —</div>
        <div class="source-badge" title="Data source status">
          <span id="sourceDot" class="source-dot warn"></span>
          <span id="sourceText" class="source-text">Source: checking…</span>
        </div>
      </div>
    </header>

    <section class="grid-top">
      <div>
        <div class="pill-row">
          <div class="feature-pill good"><span class="icon">✓</span><span class="label">Top 50 markets (backend proxy)</span></div>
          <div class="feature-pill good"><span class="icon">✓</span><span class="label">CoinGecko fallback (auto)</span></div>
          <div class="feature-pill info"><span class="icon">AI</span><span class="label">Worldwide scenario format</span></div>
          <div class="feature-pill info"><span class="icon">UX</span><span class="label">Modern blue + dark UI</span></div>
          <div class="feature-pill ad"><span class="icon">Ad</span><span class="label">Ads / affiliate slots</span></div>
          <div class="feature-pill info"><span class="icon">∞</span><span class="label">Ready for subscription</span></div>
        </div>
        <p class="mini-note">
          Markets load via the Render backend proxy. If the backend is sleeping/down, the app falls back to CoinGecko directly.
        </p>
      </div>

      <div class="top-info-card">
        <div class="card-header" style="margin-bottom:6px;">
          <div>
            <div class="card-title">CryptoVision AI module</div>
            <div class="card-subtitle">Per-coin prediction + probabilistic scenarios.</div>
          </div>
          <span class="badge blue">Live</span>
        </div>
        <p style="margin-bottom:4px;">
          <strong>How it works:</strong> select a coin and the app calls your backend <code>/ai/predict</code>,
          then formats the output into simple “Bullish / Bearish” probability scenarios.
        </p>
        <p class="mini-note">
          Educational / informational only. Not financial advice.
        </p>
      </div>
    </section>

    <!-- HOME HERO (clickable premium) -->
    <section style="margin-bottom:16px;">
      <article class="card promo-card">
        <a class="promo-link" href="premium.html" aria-label="Upgrade to Premium">
          <img class="promo-img" src="assets/cryptovision-hero.png" alt="CryptoVision – Market Intelligence" loading="lazy">
          <div class="promo-overlay"></div>
          <div class="promo-cta"><strong>Upgrade to Premium</strong><span style="opacity:.85;">• unlock advanced signals</span></div>
        </a>
      </article>
    </section>

    <!-- MAIN GRID -->
    <section class="main-grid">

      <!-- LEFT COLUMN -->
      <div>
        <!-- Market Snapshot -->
        <article class="card" style="margin-bottom:12px;">
          <div class="card-header">
            <div>
              <div class="card-title">Market Snapshot</div>
              <div class="card-subtitle">Top movers + market breadth (based on Top 50).</div>
            </div>
            <span class="badge blue">Live</span>
          </div>

          <div class="metric-grid" style="margin-bottom:12px;">
            <div class="metric-item">
              <div class="metric-label">Market breadth</div>
              <div class="metric-value" id="breadthValue">—</div>
              <div class="metric-note">Green vs red coins (24h).</div>
            </div>
            <div class="metric-item">
              <div class="metric-label">Market pulse</div>
              <div class="metric-value" id="pulseValue">—</div>
              <div class="metric-note">Avg 24h change (Top 50).</div>
            </div>
          </div>

          <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px;">
            <div>
              <div class="small-label">Top gainers (24h)</div>
              <ul class="ai-list" id="gainersList" style="margin-top:6px;"></ul>
            </div>
            <div>
              <div class="small-label">Top losers (24h)</div>
              <ul class="ai-list" id="losersList" style="margin-top:6px;"></ul>
            </div>
          </div>

          <div class="hint" style="margin-top:10px;">
            Tip: click a coin here to open it in the “Selected coin analysis” panel.
          </div>
        </article>

        <!-- Watched coins table -->
        <article class="card">
          <div class="card-header">
            <div>
              <div class="card-title">Watched coins</div>
              <div class="card-subtitle">Top 50 by market cap – backend proxy + fallback.</div>
            </div>
            <span class="badge gray">USD</span>
          </div>

          <div class="toolbar">
            <div class="search-box">
              <input id="searchInput" class="search-input" type="text" placeholder="Search coin (e.g. bitcoin, eth, bnb)..." />
            </div>
            <select id="sortSelect" class="select-small">
              <option value="rank">Sort: Market Cap</option>
              <option value="change24">Sort: Biggest 24h moves</option>
              <option value="change1h">Sort: Biggest 1h moves</option>
              <option value="change7d">Sort: Biggest 7d moves</option>
            </select>
            <button id="refreshBtn" class="btn-small primary" title="Manual refresh is rate-limited to 60s">Refresh</button>
          </div>

          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th>#</th>
                  <th>Coin</th>
                  <th>Price</th>
                  <th>1h</th>
                  <th>24h</th>
                  <th>7d</th>
                  <th>Market Cap</th>
                </tr>
              </thead>
              <tbody id="coinsBody"></tbody>
            </table>
          </div>
        </article>

        <!-- PROMO under list -->
        <article class="card promo-card" style="margin-top:12px;">
          <a class="promo-link" href="premium.html" aria-label="Upgrade to Premium">
            <img class="promo-img" src="assets/cryptovision-hero.png" alt="CryptoVision – Upgrade to Premium" loading="lazy">
            <div class="promo-overlay"></div>
            <div class="promo-cta"><strong>Upgrade to Premium</strong><span style="opacity:.85;">• AI alerts + advanced tools</span></div>
          </a>
        </article>
      </div>

      <!-- RIGHT COLUMN -->
      <div>
        <!-- Daily Insight -->
        <article class="card" style="margin-bottom:12px;">
          <div class="card-header">
            <div>
              <div class="card-title">CryptoVision – Daily Insight</div>
              <div class="card-subtitle">Quick summary based on the top 50 coins.</div>
            </div>
            <span class="badge green">Rules</span>
          </div>
          <div class="ai-text" id="dailyInsight">Loading market analysis...</div>
        </article>

        <!-- News -->
        <article class="card" style="margin-bottom:12px;">
          <div class="card-header">
            <div>
              <div class="card-title">CryptoVision – Crypto News</div>
              <div class="card-subtitle">Latest headlines (via backend RSS aggregator).</div>
            </div>
            <button id="newsRefreshBtn" class="btn-small secondary">Refresh News</button>
          </div>

          <div class="ai-text" id="newsStatus">Loading news…</div>
          <ul class="ai-list" id="newsList" style="margin-top:10px;"></ul>
        </article>

        <!-- Selected coin analysis -->
        <article class="card">
          <div class="card-header">
            <div>
              <div class="card-title">Selected coin analysis</div>
              <div class="card-subtitle">Click a coin in the list to get AI scenarios + chart.</div>
            </div>
            <span class="badge orange">Focus asset</span>
          </div>

          <div class="small-label">Selected</div>
          <div class="pair-header">
            <div>
              <div class="pair-name" id="selectedName">No coin selected</div>
              <div class="pair-symbol" id="selectedSymbol">Choose from the list</div>
            </div>
            <div class="big-price" id="selectedPrice">—</div>
          </div>

          <div class="pill-row-small" id="selectedPills">
            <span class="pill-info">Waiting for a selection...</span>
          </div>

          <!-- AI Controls -->
          <div class="controls-row">
            <select id="tfSelect" class="select-small" title="AI timeframe">
              <option value="30m">TF: 30m</option>
              <option value="1h">TF: 1h</option>
              <option value="4h">TF: 4h</option>
              <option value="1d" selected>TF: 1d</option>
            </select>
            <select id="daysSelect" class="select-small" title="History window used by AI">
              <option value="30">History: 30d</option>
              <option value="90" selected>History: 90d</option>
              <option value="180">History: 180d</option>
              <option value="365">History: 365d</option>
            </select>
            <button id="btnRetryAi" class="btn-small secondary" disabled>Retry AI</button>
            <button id="btnClearCache" class="btn-small danger" title="Clears local cache (markets + charts + ai + news)">Clear cache</button>
          </div>
          <div class="hint" id="aiHint">
            Tip: if AI is rate-limited, the app will show a clear retry countdown. Scenarios stay in English for worldwide use.
          </div>

          <div class="metric-grid">
            <div class="metric-item">
              <div class="metric-label">Market Cap</div>
              <div class="metric-value" id="metricMarketCap">—</div>
              <div class="metric-note">Project size vs market.</div>
            </div>
            <div class="metric-item">
              <div class="metric-label">AI / RSI</div>
              <div class="metric-value" id="metricBias">—</div>
              <div class="metric-note">From backend prediction.</div>
            </div>
          </div>

          <div class="ai-comment" id="coinComment">
            Select a coin to load AI prediction and probabilistic scenarios.
          </div>

          <div class="scenario-block">
            <strong>Probabilistic scenarios:</strong>
            <ul class="scenario-list" id="scenarioList"><li>—</li></ul>
          </div>

          <div class="chart-wrap">
            <div class="small-label" style="margin-bottom:4px;">Chart – last 30 days (USD)</div>
            <canvas id="priceChart"></canvas>
          </div>

          <!-- Ads / affiliate area -->
          <div class="ad-card" id="adArea">
            <strong>ADS / AFFILIATE AREA</strong><br/>
            Place your AdSense units or affiliate banners here after approval.
          </div>

          <div class="footer-note">
            Educational / informational only. Not financial advice.
          </div>
        </article>
      </div>
    </section>

    <!-- BACKEND GRID -->
    <section class="backend-grid">
      <div class="panel">
        <h2>Backend Test</h2>
        <p>
          Health: <code>/health</code> • AI: <code>/ai/predict</code> (examples: bitcoin, ethereum).
        </p>

        <div class="row">
          <label for="ai-coin-id-input" style="font-size:12px; color:var(--text-soft);">Coin ID:</label>
          <input id="ai-coin-id-input" class="input" type="text" value="bitcoin" />
          <button class="btn" type="button" id="btnTestBackend">Test AI</button>
          <button class="btn" type="button" id="btnHealth" style="background:#60a5fa;">Health</button>
        </div>

        <pre id="ai-backend-result">No request yet.</pre>
      </div>

      <div class="panel">
        <h3>AI Summary</h3>
        <p>This box updates after you call the AI endpoint.</p>
        <div style="display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; margin-top:10px; font-size:12px;">
          <div>
            <div style="opacity:.75;">Coin</div>
            <strong id="ai-summary-coin">-</strong>
          </div>
          <div>
            <div style="opacity:.75;">Last price</div>
            <strong id="ai-summary-last">-</strong>
          </div>
          <div>
            <div style="opacity:.75;">Predicted</div>
            <strong id="ai-summary-predicted">-</strong>
          </div>
          <div>
            <div style="opacity:.75;">RSI</div>
            <strong id="ai-summary-rsi">-</strong>
          </div>
        </div>
      </div>
    </section>
  </div>

  <!-- Pricing Modal -->
  <div class="modal-backdrop" id="pricingModal" role="dialog" aria-modal="true" aria-label="Plans and pricing">
    <div class="modal">
      <div class="modal-head">
        <h3>Plans & Pricing</h3>
        <button class="modal-close" id="btnClosePricing" type="button">Close</button>
      </div>
      <div class="modal-body">
        <div class="ai-text">
          Choose a plan. For now, plan selection is stored locally (demo mode). When you integrate payments (Stripe / PayPal),
          you will replace the “Activate” actions with real checkout flows.
        </div>

        <div class="plan-grid">
          <div class="plan">
            <span class="tag">Default</span>
            <h4>Free</h4>
            <div class="price">$0</div>
            <div class="desc">
              1 coin/day free. Additional coins require a rewarded video ad, max 3/day.
            </div>
            <ul>
              <li>1 free coin view per day</li>
              <li>Rewarded video for extra views</li>
              <li>Max 3 rewarded views/day</li>
              <li>Good for testing</li>
            </ul>
            <div class="actions">
              <button class="btn-small primary" type="button" id="btnPlanFree">Activate Free</button>
            </div>
          </div>

          <div class="plan">
            <span class="tag">Best value</span>
            <h4>Premium Basic</h4>
            <div class="price">$3.99<span style="font-size:12px;opacity:.8;">/month</span></div>
            <div class="desc">
              Up to 10 coins/day. No rewarded ads.
            </div>
            <ul>
              <li>10 coin views per day</li>
              <li>No rewarded ads</li>
              <li>Faster flow, less friction</li>
            </ul>
            <div class="actions">
              <button class="btn-small primary" type="button" id="btnPlanBasic">Activate Basic</button>
              <a class="btn-small secondary" href="premium.html">Premium page</a>
            </div>
          </div>

          <div class="plan">
            <span class="tag">Pro</span>
            <h4>Premium Unlimited</h4>
            <div class="price">$9.99<span style="font-size:12px;opacity:.8;">/month</span></div>
            <div class="desc">
              Unlimited coins/day. No rewarded ads.
            </div>
            <ul>
              <li>Unlimited coin views</li>
              <li>No rewarded ads</li>
              <li>Best for daily traders</li>
            </ul>
            <div class="actions">
              <button class="btn-small primary" type="button" id="btnPlanUnlimited">Activate Unlimited</button>
              <a class="btn-small secondary" href="premium.html">Premium page</a>
            </div>
          </div>
        </div>

        <div class="note">
          <strong>Important:</strong> “Rewarded video ads” are shown here as a placeholder button. Once AdSense/AdMob (or another provider)
          is integrated, you will trigger a real rewarded ad and only then allow the extra coin view.
        </div>
      </div>
    </div>
  </div>

  <script>
    "use strict";

    // ==========================================================
    // CONFIG
    // ==========================================================
    const API_BASE = "https://api.coingecko.com/api/v3";
    const BACKEND_BASE_URL = "https://cryptovision-ldo7.onrender.com"; // no trailing slash
    const BACKEND_MARKETS_ENDPOINT = "/coins/markets";

    const REFRESH_MIN_INTERVAL_MS = 60_000;
    const MARKETS_CACHE_TTL_MS = 60_000;
    const STORAGE_KEY_MARKETS = "cv_markets_cache_v2";

    const AI_CACHE_TTL_MS = 120_000;

    const NEWS_ENDPOINT = "/news";
    const NEWS_CACHE_TTL_MS = 5 * 60_000;
    const NEWS_REFRESH_MIN_INTERVAL_MS = 30_000;
    const STORAGE_KEY_NEWS = "cv_news_cache_v2";

    const AI_ENDPOINT = "/ai/predict";
    const CHART_ENDPOINT = "/chart";
    const STORAGE_KEY_PREFS = "cv_prefs_v2";

    // Monetization / plan
    const STORAGE_KEY_PLAN = "cv_plan_v1";
    const STORAGE_KEY_USAGE = "cv_usage_v1";

    const Plans = {
      FREE: { id: "free", label: "Free", coinViewsPerDay: 1, rewardedExtraMaxPerDay: 3, rewardedRequiredAfterFree: true },
      BASIC: { id: "basic", label: "Premium Basic", coinViewsPerDay: 10, rewardedExtraMaxPerDay: 0, rewardedRequiredAfterFree: false },
      UNLIMITED: { id: "unlimited", label: "Premium Unlimited", coinViewsPerDay: Infinity, rewardedExtraMaxPerDay: 0, rewardedRequiredAfterFree: false }
    };

    // ==========================================================
    // Helpers (safe DOM)
    // ==========================================================
    const $ = (id) => document.getElementById(id);
    function on(el, ev, fn) { if (el) el.addEventListener(ev, fn, { passive: true }); }

    // ==========================================================
    // DOM
    // ==========================================================
    const coinsBody = $("coinsBody");
    const searchInput = $("searchInput");
    const sortSelect = $("sortSelect");
    const refreshBtn = $("refreshBtn");
    const updatedAtText = $("updatedAtText");
    const dailyInsightEl = $("dailyInsight");

    const sourceDot = $("sourceDot");
    const sourceText = $("sourceText");

    const selectedNameEl = $("selectedName");
    const selectedSymbolEl = $("selectedSymbol");
    const selectedPriceEl = $("selectedPrice");
    const selectedPillsEl = $("selectedPills");
    const metricMarketCapEl = $("metricMarketCap");
    const metricBiasEl = $("metricBias");
    const coinCommentEl = $("coinComment");
    const scenarioListEl = $("scenarioList");

    const aiInput = $("ai-coin-id-input");
    const aiResult = $("ai-backend-result");
    const btnTestBackend = $("btnTestBackend");
    const btnHealth = $("btnHealth");

    const tfSelect = $("tfSelect");
    const daysSelect = $("daysSelect");
    const btnRetryAi = $("btnRetryAi");
    const btnClearCache = $("btnClearCache");
    const aiHint = $("aiHint");

    const newsListEl = $("newsList");
    const newsStatusEl = $("newsStatus");
    const newsRefreshBtn = $("newsRefreshBtn");

    // Market Snapshot DOM
    const breadthValueEl = $("breadthValue");
    const pulseValueEl = $("pulseValue");
    const gainersListEl = $("gainersList");
    const losersListEl = $("losersList");

    // Pricing / usage DOM
    const usagePill = $("usagePill");
    const btnOpenPricing = $("btnOpenPricing");
    const pricingModal = $("pricingModal");
    const btnClosePricing = $("btnClosePricing");
    const btnPlanFree = $("btnPlanFree");
    const btnPlanBasic = $("btnPlanBasic");
    const btnPlanUnlimited = $("btnPlanUnlimited");

    // ==========================================================
    // STATE
    // ==========================================================
    let coinsRaw = [];
    let filteredCoins = [];
    let currentSort = "rank";
    let priceChart = null;

    const chartCache = new Map();
    const aiCache = new Map();

    const DataSource = {
      BACKEND: "backend-proxy",
      COINGECKO: "coingecko-direct",
      CACHE: "cache"
    };

    let isLoadingMarkets = false;
    let lastManualRefreshTs = 0;

    let selectedCoinId = null;
    let aiRetryTimer = null;
    let aiRetryRemainingSec = 0;
    let forceAiRefresh = false;

    let lastNewsRefreshTs = 0;

    // ==========================================================
    // UTIL
    // ==========================================================
    function todayKey() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const da = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${da}`;
    }

    function safeNum(x) {
      const n = Number(x);
      return Number.isFinite(n) ? n : null;
    }

    function escapeHtml(s) {
      const str = String(s ?? "");
      return str
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function updateTimestamp() {
      if (!updatedAtText) return;
      const now = new Date();
      const formatted = now.toLocaleString("en-GB", {
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit"
      });
      updatedAtText.textContent = "Updated: " + formatted;
    }

    function formatPrice(value) {
      if (value == null || Number.isNaN(value)) return "—";
      const v = Number(value);
      if (!Number.isFinite(v)) return "—";
      if (v >= 1000) return "$" + v.toLocaleString("en-US", { maximumFractionDigits: 0 });
      if (v >= 1) return "$" + v.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      if (v >= 0.01) return "$" + v.toLocaleString("en-US", { minimumFractionDigits: 4, maximumFractionDigits: 4 });
      return "$" + v.toLocaleString("en-US", { minimumFractionDigits: 6, maximumFractionDigits: 8 });
    }

    function formatPercent(value) {
      if (value == null || Number.isNaN(value)) return "—";
      const v = Number(value);
      if (!Number.isFinite(v)) return "—";
      const sign = v > 0 ? "+" : "";
      return sign + v.toFixed(2) + "%";
    }

    function formatNumberAbbr(value) {
      if (value == null || Number.isNaN(value)) return "—";
      const v = Number(value);
      if (!Number.isFinite(v)) return "—";
      if (v >= 1e12) return (v / 1e12).toFixed(2) + " T";
      if (v >= 1e9)  return (v / 1e9).toFixed(2) + " B";
      if (v >= 1e6)  return (v / 1e6).toFixed(2) + " M";
      if (v >= 1e3)  return (v / 1e3).toFixed(2) + " K";
      return v.toFixed(0);
    }

    function setSourceBadge(kind, msg) {
      if (!sourceDot || !sourceText) return;
      sourceDot.classList.remove("ok", "warn", "bad");
      if (kind === DataSource.BACKEND) sourceDot.classList.add("ok");
      else if (kind === DataSource.COINGECKO) sourceDot.classList.add("warn");
      else if (kind === DataSource.CACHE) sourceDot.classList.add("warn");
      else sourceDot.classList.add("bad");
      sourceText.textContent = msg;
    }

    function showErrorInTable(message) {
      if (!coinsBody) return;
      coinsBody.innerHTML = "";
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 7;
      td.style.textAlign = "left";
      td.style.color = "#fca5a5";
      td.textContent = message;
      tr.appendChild(td);
      coinsBody.appendChild(tr);
    }

    function showLoadingRow(message = "Loading…") {
      if (!coinsBody) return;
      coinsBody.innerHTML = "";
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 7;
      td.style.textAlign = "left";
      td.style.color = "#9ca3af";
      td.textContent = message;
      tr.appendChild(td);
      coinsBody.appendChild(tr);
    }

    // ==========================================================
    // PLAN / USAGE (local demo implementation)
    // ==========================================================
    function loadPlan() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_PLAN);
        const id = (raw || "free").toLowerCase();
        if (id === "basic") return Plans.BASIC;
        if (id === "unlimited") return Plans.UNLIMITED;
        return Plans.FREE;
      } catch {
        return Plans.FREE;
      }
    }

    function savePlan(planId) {
      try { localStorage.setItem(STORAGE_KEY_PLAN, planId); } catch {}
      updateUsagePill();
    }

    function loadUsage() {
      const key = todayKey();
      try {
        const raw = localStorage.getItem(STORAGE_KEY_USAGE);
        if (!raw) return { day: key, coinViews: 0, rewardedViews: 0, uniqueCoins: {} };
        const u = JSON.parse(raw);
        if (!u || u.day !== key) return { day: key, coinViews: 0, rewardedViews: 0, uniqueCoins: {} };
        if (!u.uniqueCoins || typeof u.uniqueCoins !== "object") u.uniqueCoins = {};
        return u;
      } catch {
        return { day: key, coinViews: 0, rewardedViews: 0, uniqueCoins: {} };
      }
    }

    function saveUsage(u) {
      try { localStorage.setItem(STORAGE_KEY_USAGE, JSON.stringify(u)); } catch {}
      updateUsagePill();
    }

    function updateUsagePill() {
      if (!usagePill) return;
      const plan = loadPlan();
      const u = loadUsage();
      const limit = (plan.coinViewsPerDay === Infinity) ? "∞" : String(plan.coinViewsPerDay);
      const extra = (plan.rewardedExtraMaxPerDay || 0);
      usagePill.textContent =
        `Plan: ${plan.label} • Usage today: ${u.coinViews}/${limit} • Rewarded used: ${u.rewardedViews}/${extra}`;
    }

    async function showRewardedAdPlaceholder() {
      // Placeholder for real rewarded video.
      // Replace this with AdSense/AdMob rewarded flow later.
      return confirm("Watch a rewarded video ad to unlock this coin view? (demo placeholder)");
    }

    async function enforceAccessForCoin(coinId) {
      const plan = loadPlan();
      const u = loadUsage();

      // If the same coin was already opened today, don't count again
      if (u.uniqueCoins && u.uniqueCoins[coinId]) return { ok: true, reason: "already-counted" };

      // Unlimited plan
      if (plan.coinViewsPerDay === Infinity) {
        u.coinViews += 1;
        u.uniqueCoins[coinId] = true;
        saveUsage(u);
        return { ok: true, reason: "unlimited" };
      }

      // Within plan limit
      if (u.coinViews < plan.coinViewsPerDay) {
        u.coinViews += 1;
        u.uniqueCoins[coinId] = true;
        saveUsage(u);
        return { ok: true, reason: "within-limit" };
      }

      // Free plan rewarded extras
      if (plan.id === Plans.FREE.id && plan.rewardedRequiredAfterFree) {
        if (u.rewardedViews >= plan.rewardedExtraMaxPerDay) {
          return {
            ok: false,
            reason: "rewarded-limit",
            message: "Daily limit reached for rewarded views (max 3/day). Try again tomorrow or upgrade to Premium."
          };
        }

        const watched = await showRewardedAdPlaceholder();
        if (!watched) {
          return { ok: false, reason: "rewarded-cancel", message: "Rewarded ad not completed. Upgrade or try again." };
        }

        u.rewardedViews += 1;
        u.coinViews += 1;
        u.uniqueCoins[coinId] = true;
        saveUsage(u);
        return { ok: true, reason: "rewarded-granted" };
      }

      // Basic cap reached
      return {
        ok: false,
        reason: "plan-cap",
        message: `Daily plan limit reached (${plan.coinViewsPerDay}/day). Upgrade to Unlimited for unlimited access.`
      };
    }

    // ==========================================================
    // Market Snapshot
    // ==========================================================
    function renderMarketSnapshot() {
      if (!Array.isArray(coinsRaw) || coinsRaw.length === 0) {
        if (breadthValueEl) breadthValueEl.textContent = "—";
        if (pulseValueEl) pulseValueEl.textContent = "—";
      } else {
        let green = 0, red = 0, sum24 = 0, count24 = 0;
        for (const c of coinsRaw) {
          const chg = Number(c?.price_change_percentage_24h);
          if (Number.isFinite(chg)) {
            sum24 += chg;
            count24++;
            if (chg > 0) green++;
            else if (chg < 0) red++;
          }
        }
        const avg24 = count24 ? (sum24 / count24) : 0;
        if (breadthValueEl) breadthValueEl.textContent = `${green} green / ${red} red`;
        if (pulseValueEl) pulseValueEl.textContent = `${avg24.toFixed(2)}%`;
      }

      const base = Array.isArray(filteredCoins) && filteredCoins.length ? filteredCoins : coinsRaw;
      const withChg = (base || [])
        .filter(c => Number.isFinite(Number(c?.price_change_percentage_24h)))
        .map(c => ({ ...c, _chg24: Number(c.price_change_percentage_24h) }));

      const gainers = [...withChg].sort((a, b) => b._chg24 - a._chg24).slice(0, 5);
      const losers  = [...withChg].sort((a, b) => a._chg24 - b._chg24).slice(0, 5);

      function renderList(listEl, items) {
        if (!listEl) return;
        listEl.innerHTML = "";
        if (!items.length) {
          const li = document.createElement("li");
          li.style.opacity = "0.8";
          li.textContent = "—";
          listEl.appendChild(li);
          return;
        }
        for (const c of items) {
          const li = document.createElement("li");
          const chg = c._chg24;
          const chgClass = chg > 0 ? "chg-pos" : chg < 0 ? "chg-neg" : "";
          li.style.cursor = "pointer";
          li.innerHTML = `
            <span><strong>${escapeHtml(c.name || "Unknown")}</strong>
              <span style="opacity:.75;">(${escapeHtml((c.symbol || "").toUpperCase())})</span>
            </span>
            <span class="${chgClass}" style="float:right;">${formatPercent(chg)}</span>
          `;
          li.addEventListener("click", () => handleCoinClick(c.id));
          listEl.appendChild(li);
        }
      }

      renderList(gainersListEl, gainers);
      renderList(losersListEl, losers);
    }

    // ==========================================================
    // PREFS
    // ==========================================================
    function loadPrefs() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_PREFS);
        if (!raw) return { tf: "1d", days: 90 };
        const p = JSON.parse(raw);
        return {
          tf: (p && typeof p.tf === "string") ? p.tf : "1d",
          days: (p && Number.isFinite(Number(p.days))) ? Number(p.days) : 90
        };
      } catch {
        return { tf: "1d", days: 90 };
      }
    }

    function savePrefs(tf, days) {
      try { localStorage.setItem(STORAGE_KEY_PREFS, JSON.stringify({ tf, days })); } catch {}
    }

    // ==========================================================
    // CACHE: markets/news
    // ==========================================================
    function loadMarketsCache() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_MARKETS);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !Array.isArray(parsed.data) || typeof parsed.ts !== "number") return null;
        return parsed;
      } catch { return null; }
    }

    function saveMarketsCache(data) {
      try { localStorage.setItem(STORAGE_KEY_MARKETS, JSON.stringify({ ts: Date.now(), data })); } catch {}
    }

    function isCacheFresh(ts) {
      return (Date.now() - ts) <= MARKETS_CACHE_TTL_MS;
    }

    function loadNewsCache() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_NEWS);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !Array.isArray(parsed.items) || typeof parsed.ts !== "number") return null;
        return parsed;
      } catch { return null; }
    }

    function saveNewsCache(items) {
      try { localStorage.setItem(STORAGE_KEY_NEWS, JSON.stringify({ ts: Date.now(), items })); } catch {}
    }

    function isNewsCacheFresh(ts) {
      return (Date.now() - ts) <= NEWS_CACHE_TTL_MS;
    }

    function clearAllCaches() {
      try { localStorage.removeItem(STORAGE_KEY_MARKETS); } catch {}
      try { localStorage.removeItem(STORAGE_KEY_NEWS); } catch {}

      chartCache.clear();
      aiCache.clear();

      if (coinCommentEl) coinCommentEl.textContent = "Cache cleared. Select a coin again.";
      if (scenarioListEl) scenarioListEl.innerHTML = "<li>—</li>";
      if (aiHint) aiHint.textContent = "Cache cleared.";

      if (newsStatusEl) newsStatusEl.textContent = "News cache cleared. Click Refresh News.";
      if (newsListEl) newsListEl.innerHTML = "";

      if (priceChart) { priceChart.destroy(); priceChart = null; }

      renderMarketSnapshot();
    }

    // ==========================================================
    // NET
    // ==========================================================
    async function fetchJsonDetailed(url, { timeoutMs = 15000, mode = "cors", retries = 0, retryDelayMs = 900 } = {}) {
      let lastErr = null;
      for (let attempt = 0; attempt <= retries; attempt++) {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeoutMs);
        try {
          const res = await fetch(url, {
            method: "GET",
            cache: "no-store",
            mode,
            signal: controller.signal,
            headers: { "Accept": "application/json" }
          });

          const contentType = (res.headers.get("content-type") || "").toLowerCase();
          const isJson = contentType.includes("application/json");

          let body = null;
          let text = "";

          if (isJson) body = await res.json().catch(() => null);
          else text = await res.text().catch(() => "");

          if (!res.ok) {
            const msg = isJson ? JSON.stringify(body).slice(0, 260) : (text || "").slice(0, 260);
            const err = new Error(`HTTP ${res.status} ${res.statusText}${msg ? (" - " + msg) : ""}`);
            err.status = res.status;
            err.headers = res.headers;
            err.body = body;
            throw err;
          }

          return { ok: true, status: res.status, headers: res.headers, data: body };
        } catch (err) {
          lastErr = err;
          if (attempt === retries) break;
          const wait = retryDelayMs * Math.pow(1.6, attempt);
          await new Promise(r => setTimeout(r, wait));
        } finally {
          clearTimeout(timer);
        }
      }
      throw lastErr;
    }

    async function fetchJsonWithRetry(url, opts = {}) {
      const res = await fetchJsonDetailed(url, opts);
      return res.data;
    }

    // ==========================================================
    // URL builders
    // ==========================================================
    function buildMarketsUrlBase(base) {
      const normalized = base.endsWith("/") ? base.slice(0, -1) : base;
      return (
        normalized + BACKEND_MARKETS_ENDPOINT +
        `?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false&price_change_percentage=1h,24h,7d`
      );
    }

    function buildCoinGeckoMarketsUrl() {
      return (
        API_BASE + "/coins/markets" +
        `?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false&price_change_percentage=1h,24h,7d`
      );
    }

    function buildAiUrl({ coinId, days = 90, timeframe = "1d" }) {
      const base = BACKEND_BASE_URL.replace(/\/$/, "");
      const qs = new URLSearchParams({ coin_id: coinId, days: String(days), timeframe: String(timeframe) });
      return `${base}${AI_ENDPOINT}?${qs.toString()}`;
    }

    function buildBackendChartUrl({ coinId, vsCurrency = "usd", days = 30, interval = "daily" }) {
      const base = BACKEND_BASE_URL.replace(/\/$/, "");
      const qs = new URLSearchParams({ coin_id: coinId, vs_currency: vsCurrency, days: String(days), interval: String(interval) });
      return `${base}${CHART_ENDPOINT}?${qs.toString()}`;
    }

    function buildNewsUrl({ limit = 12 } = {}) {
      const base = BACKEND_BASE_URL.replace(/\/$/, "");
      const qs = new URLSearchParams({ limit: String(limit) });
      return `${base}${NEWS_ENDPOINT}?${qs.toString()}`;
    }

    // ==========================================================
    // NEWS
    // ==========================================================
    function normalizeNewsPayload(payload) {
      if (Array.isArray(payload)) return payload;
      if (payload && Array.isArray(payload.items)) return payload.items;
      return [];
    }

    function renderNewsItems(items) {
      if (!newsListEl || !newsStatusEl) return;
      newsListEl.innerHTML = "";
      if (!items || !items.length) {
        newsStatusEl.textContent = "No news items available right now.";
        return;
      }

      const max = Math.min(items.length, 20);
      for (let i = 0; i < max; i++) {
        const it = items[i] || {};
        const title = String(it.title || it.headline || "Untitled");
        const url = String(it.url || it.link || "");
        const source = String(it.source || it.publisher || "");
        const published = String(it.published_at || it.published || it.date || "");

        const li = document.createElement("li");

        const safeTitle = escapeHtml(title);
        const safeSource = escapeHtml(source);
        const safePublished = escapeHtml(published);
        const meta = [safeSource, safePublished].filter(Boolean).join(" • ");

        if (url && (url.startsWith("http://") || url.startsWith("https://"))) {
          li.innerHTML = `
            <a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="color:#bfdbfe; text-decoration:none;">
              <strong>${safeTitle}</strong>
            </a>
            ${meta ? `<div style="margin-top:2px; color:#9ca3af; font-size:11px;">${meta}</div>` : ""}
          `;
        } else {
          li.innerHTML = `
            <strong>${safeTitle}</strong>
            ${meta ? `<div style="margin-top:2px; color:#9ca3af; font-size:11px;">${meta}</div>` : ""}
          `;
        }
        newsListEl.appendChild(li);
      }

      newsStatusEl.textContent = `Showing ${max} headlines.`;
    }

    async function loadNews({ force = false } = {}) {
      if (!newsListEl || !newsStatusEl || !newsRefreshBtn) return;

      if (!force) {
        const cached = loadNewsCache();
        if (cached && isNewsCacheFresh(cached.ts)) {
          renderNewsItems(cached.items);
          const ageSec = Math.max(0, Math.floor((Date.now() - cached.ts) / 1000));
          newsStatusEl.textContent = `News loaded from cache (${ageSec}s ago).`;
          return;
        }
      }

      const now = Date.now();
      if (!force) {
        const elapsed = now - lastNewsRefreshTs;
        if (elapsed < NEWS_REFRESH_MIN_INTERVAL_MS) {
          const remaining = Math.ceil((NEWS_REFRESH_MIN_INTERVAL_MS - elapsed) / 1000);
          newsStatusEl.textContent = `Please wait ${remaining}s before refreshing news again.`;
          return;
        }
      }
      lastNewsRefreshTs = now;

      newsRefreshBtn.disabled = true;
      const oldBtnText = newsRefreshBtn.textContent;
      newsRefreshBtn.textContent = "Loading…";
      newsStatusEl.textContent = "Loading news from backend…";

      try {
        const url = buildNewsUrl({ limit: 12 });
        const res = await fetchJsonDetailed(url, { timeoutMs: 20000, retries: 1, retryDelayMs: 1100, mode: "cors" });
        const items = normalizeNewsPayload(res.data);
        const normalized = Array.isArray(items) ? items : [];
        saveNewsCache(normalized);
        renderNewsItems(normalized);
      } catch (e) {
        console.error("[News] failed:", e);
        const cached = loadNewsCache();
        if (cached && Array.isArray(cached.items) && cached.items.length) {
          renderNewsItems(cached.items);
          newsStatusEl.textContent = "News backend unavailable. Showing cached headlines.";
        } else {
          newsListEl.innerHTML = "";
          newsStatusEl.textContent = "News backend unavailable. Please try again later.";
        }
      } finally {
        newsRefreshBtn.disabled = false;
        newsRefreshBtn.textContent = oldBtnText;
      }
    }

    // ==========================================================
    // MARKETS loader
    // ==========================================================
    async function loadMarkets({ reason = "auto" } = {}) {
      if (isLoadingMarkets) return;
      isLoadingMarkets = true;

      try {
        if (refreshBtn) { refreshBtn.disabled = true; refreshBtn.textContent = "Loading…"; }
        if (dailyInsightEl) dailyInsightEl.textContent = "Loading market analysis...";
        showLoadingRow("Loading…");

        const cached = loadMarketsCache();
        const hasFreshCache = cached && isCacheFresh(cached.ts);

        if (hasFreshCache) {
          coinsRaw = cached.data.filter(Boolean);
          filteredCoins = [...coinsRaw];
          applySort();
          renderTable();
          makeDailyInsight();
          renderMarketSnapshot();
          updateTimestamp();
          setSourceBadge(DataSource.CACHE, "Source: cache (last 60s) ✓");
          if (reason !== "manual") return;
        }

        const backendUrl = buildMarketsUrlBase(BACKEND_BASE_URL);
        try {
          const backendRes = await fetchJsonDetailed(backendUrl, { timeoutMs: 15000, retries: 1, retryDelayMs: 1000 });
          const backendData = backendRes.data;
          if (!Array.isArray(backendData)) throw new Error("Backend returned non-array JSON.");
          coinsRaw = backendData.filter(Boolean);
          saveMarketsCache(coinsRaw);
          setSourceBadge(DataSource.BACKEND, `Source: backend proxy ✓ (${BACKEND_BASE_URL})`);
        } catch (errBackend) {
          console.warn("[Markets] backend failed, falling back to CoinGecko direct.", errBackend);
          setSourceBadge(DataSource.COINGECKO, "Source: CoinGecko direct (backend fallback) ⚠");
          const cgUrl = buildCoinGeckoMarketsUrl();
          const cgRes = await fetchJsonDetailed(cgUrl, { timeoutMs: 15000, retries: 1, retryDelayMs: 1200 });
          const cgData = cgRes.data;
          if (!Array.isArray(cgData)) throw new Error("CoinGecko returned non-array JSON.");
          coinsRaw = cgData.filter(Boolean);
          saveMarketsCache(coinsRaw);
        }

        filteredCoins = [...coinsRaw];
        applySort();
        renderTable();
        makeDailyInsight();
        renderMarketSnapshot();
        updateTimestamp();

      } catch (err) {
        console.error("[Markets] load failed:", err);
        const cached = loadMarketsCache();
        if (cached && Array.isArray(cached.data) && cached.data.length) {
          coinsRaw = cached.data.filter(Boolean);
          filteredCoins = [...coinsRaw];
          applySort();
          renderTable();
          makeDailyInsight();
          renderMarketSnapshot();
          updateTimestamp();
          setSourceBadge(DataSource.CACHE, "Source: cache (fallback after error) ⚠");
          if (dailyInsightEl) dailyInsightEl.textContent = "Loaded from cache due to upstream error.";
        } else {
          setSourceBadge("error", "Source: FAILED (backend + CoinGecko + no cache)");
          showErrorInTable("Failed to load markets. Please try again in 60s.");
          if (dailyInsightEl) dailyInsightEl.textContent = "Error loading data (rate limit / backend / network).";
          renderMarketSnapshot();
        }
      } finally {
        isLoadingMarkets = false;
        if (refreshBtn) { refreshBtn.disabled = false; refreshBtn.textContent = "Refresh"; }
      }
    }

    // ==========================================================
    // SORT / FILTER / TABLE
    // ==========================================================
    function applySort() {
      const key = currentSort;
      filteredCoins.sort((a, b) => {
        if (key === "rank") return (a.market_cap_rank ?? 9999) - (b.market_cap_rank ?? 9999);
        if (key === "change24") return Math.abs(b.price_change_percentage_24h || 0) - Math.abs(a.price_change_percentage_24h || 0);
        if (key === "change1h") return Math.abs(b.price_change_percentage_1h_in_currency || 0) - Math.abs(a.price_change_percentage_1h_in_currency || 0);
        if (key === "change7d") return Math.abs(b.price_change_percentage_7d_in_currency || 0) - Math.abs(a.price_change_percentage_7d_in_currency || 0);
        return 0;
      });
    }

    function renderTable() {
      if (!coinsBody) return;
      coinsBody.innerHTML = "";

      if (!filteredCoins.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 7;
        td.style.textAlign = "left";
        td.style.color = "#9ca3af";
        td.textContent = "No data yet. Try Refresh.";
        tr.appendChild(td);
        coinsBody.appendChild(tr);
        return;
      }

      const frag = document.createDocumentFragment();
      for (const coin of filteredCoins) {
        const tr = document.createElement("tr");
        tr.dataset.id = coin.id;

        const rankTd = document.createElement("td");
        rankTd.innerHTML = `<span class="rank">${coin.market_cap_rank ?? "?"}</span>`;
        tr.appendChild(rankTd);

        const nameTd = document.createElement("td");
        nameTd.innerHTML = `
          <div class="coin-name">
            <span>${escapeHtml(coin.name ?? "Unknown")}</span>
            <span class="coin-symbol">${escapeHtml((coin.symbol ?? "?").toUpperCase())}</span>
          </div>
        `;
        tr.appendChild(nameTd);

        const priceTd = document.createElement("td");
        priceTd.textContent = formatPrice(coin.current_price);
        tr.appendChild(priceTd);

        const chg1hTd = document.createElement("td");
        const chg1h = coin.price_change_percentage_1h_in_currency;
        chg1hTd.textContent = formatPercent(chg1h);
        chg1hTd.className = chg1h > 0 ? "chg-pos" : chg1h < 0 ? "chg-neg" : "";
        tr.appendChild(chg1hTd);

        const chg24Td = document.createElement("td");
        const chg24 = coin.price_change_percentage_24h;
        chg24Td.textContent = formatPercent(chg24);
        chg24Td.className = chg24 > 0 ? "chg-pos" : chg24 < 0 ? "chg-neg" : "";
        tr.appendChild(chg24Td);

        const chg7dTd = document.createElement("td");
        const chg7d = coin.price_change_percentage_7d_in_currency;
        chg7dTd.textContent = formatPercent(chg7d);
        chg7dTd.className = chg7d > 0 ? "chg-pos" : chg7d < 0 ? "chg-neg" : "";
        tr.appendChild(chg7dTd);

        const mcTd = document.createElement("td");
        mcTd.textContent = "$" + formatNumberAbbr(coin.market_cap ?? 0);
        tr.appendChild(mcTd);

        tr.addEventListener("click", () => handleCoinClick(coin.id));
        frag.appendChild(tr);
      }
      coinsBody.appendChild(frag);
    }

    function filterCoins() {
      const q = (searchInput?.value || "").toLowerCase().trim();
      if (!q) filteredCoins = [...coinsRaw];
      else {
        filteredCoins = coinsRaw.filter((c) =>
          (c.name || "").toLowerCase().includes(q) ||
          (c.symbol || "").toLowerCase().includes(q)
        );
      }
      applySort();
      renderTable();
      renderMarketSnapshot();
    }

    // ==========================================================
    // DAILY INSIGHT (rules)
    // ==========================================================
    function makeDailyInsight() {
      if (!dailyInsightEl) return;

      if (!coinsRaw.length) {
        dailyInsightEl.textContent = "Not enough data yet. Try refresh.";
        return;
      }

      let sum24 = 0, count24 = 0;
      let topGainer = null, topLoser = null;
      let highVolMoves = 0;

      for (const c of coinsRaw) {
        const chg = c.price_change_percentage_24h;
        if (chg != null && !Number.isNaN(chg)) {
          sum24 += chg;
          count24++;
          if (!topGainer || chg > (topGainer.price_change_percentage_24h ?? -9999)) topGainer = c;
          if (!topLoser || chg < (topLoser.price_change_percentage_24h ?? 9999)) topLoser = c;
          if (Math.abs(chg) >= 5) highVolMoves++;
        }
      }

      const avg24 = count24 ? (sum24 / count24) : 0;
      let mood = "balanced / sideways";
      if (avg24 > 1.5) mood = "bullish";
      else if (avg24 < -1.5) mood = "bearish";

      const volatility =
        highVolMoves >= 10 ? "high (many moves > ±5% in 24h)"
        : highVolMoves >= 4 ? "medium (some strong spikes)"
        : "low (mostly moderate moves)";

      dailyInsightEl.innerHTML = `
        <p>
          Based on <strong>${count24}</strong> top coins by market cap, today’s market mood looks
          <strong>${mood}</strong>, with an average 24h change of <strong>${avg24.toFixed(2)}%</strong>.
        </p>
        <ul class="ai-list">
          <li><strong>Top gainer:</strong> <strong>${escapeHtml(topGainer?.name ?? "N/A")}</strong> (${formatPercent(topGainer?.price_change_percentage_24h)} / 24h)</li>
          <li><strong>Top loser:</strong> <strong>${escapeHtml(topLoser?.name ?? "N/A")}</strong> (${formatPercent(topLoser?.price_change_percentage_24h)} / 24h)</li>
          <li><strong>Volatility:</strong> <strong>${volatility}</strong></li>
          <li>Educational only, not financial advice.</li>
        </ul>
      `;
    }

    // ==========================================================
    // AI scenarios
    // ==========================================================
    function computeProbabilisticScenarios({ last, predicted, low, high }) {
      const lastN = safeNum(last);
      const predN = safeNum(predicted);
      const lowN0 = safeNum(low);
      const highN0 = safeNum(high);

      if (lastN == null || predN == null || lowN0 == null || highN0 == null) {
        return [
          { label: "Bullish", prob: 62, from: null, to: null },
          { label: "Bearish", prob: 28, from: null, to: null },
          { label: "Breakout", prob: 10, from: null, to: null }
        ];
      }

      const lowN = Math.min(lowN0, highN0);
      const highN = Math.max(lowN0, highN0);

      const denom = Math.max(1e-9, Math.abs(lastN));
      const widthAbs = Math.max(0, highN - lowN);
      const widthRel = widthAbs / denom;

      const MIN_MOVE_REL = 0.005;
      const minMoveAbs = Math.abs(lastN) * MIN_MOVE_REL;

      const tight = widthRel < 0.04;
      const pMain = tight ? 65 : 62;
      const pAlt  = tight ? 25 : 28;
      const pRare = Math.max(5, 100 - pMain - pAlt);

      const deltaRel = (predN - lastN) / denom;
      const mainIsBull = deltaRel >= 0;

      const mainLabel = mainIsBull ? "Bullish" : "Bearish";
      const altLabel  = mainIsBull ? "Bearish" : "Bullish";
      const rareLabel = mainIsBull ? "Bullish breakout" : "Bearish breakdown";

      const predClamped = Math.min(highN, Math.max(lowN, predN));
      const intervalCanSupportMove = widthAbs >= (minMoveAbs * 0.9);

      let mainTo = null;
      if (intervalCanSupportMove) {
        if (mainIsBull) {
          const candidate = Math.max(predClamped, lastN + minMoveAbs);
          mainTo = Math.min(highN, candidate);
          if (!(mainTo > lastN)) mainTo = null;
        } else {
          const candidate = Math.min(predClamped, lastN - minMoveAbs);
          mainTo = Math.max(lowN, candidate);
          if (!(mainTo < lastN)) mainTo = null;
        }
      }

      let altTo = null;
      if (intervalCanSupportMove) {
        if (mainIsBull) {
          const candidate = Math.min(predClamped, lastN - minMoveAbs);
          altTo = Math.max(lowN, candidate);
          if (!(altTo < lastN)) altTo = null;
        } else {
          const candidate = Math.max(predClamped, lastN + minMoveAbs);
          altTo = Math.min(highN, candidate);
          if (!(altTo > lastN)) altTo = null;
        }
      }

      const OUT_REL = 0.006;
      const OUT_MIN = 0.002;
      let rareTo;
      if (mainIsBull) rareTo = Math.max(highN * (1 + OUT_REL), highN * (1 + OUT_MIN));
      else rareTo = Math.min(lowN * (1 - OUT_REL), lowN * (1 - OUT_MIN));

      return [
        { label: mainLabel, prob: pMain, from: lastN, to: mainTo },
        { label: altLabel,  prob: pAlt,  from: lastN, to: altTo },
        { label: rareLabel, prob: pRare, from: lastN, to: rareTo }
      ];
    }

    function renderProbabilisticScenarioList(scenarios) {
      if (!scenarioListEl) return;
      scenarioListEl.innerHTML = "";
      if (!Array.isArray(scenarios) || scenarios.length === 0) {
        scenarioListEl.innerHTML = "<li>No scenarios available.</li>";
        return;
      }

      for (const s of scenarios) {
        const li = document.createElement("li");
        const label = (s && typeof s.label === "string" && s.label.trim()) ? s.label : "Scenario";
        const probNum = Number(s?.prob);
        const probTxt = Number.isFinite(probNum) ? `${probNum.toFixed(0)}%` : "—";
        const fromTxt = (s?.from == null) ? "—" : formatPrice(s.from);
        const toTxt   = (s?.to == null) ? "—" : formatPrice(s.to);

        li.innerHTML = `
          <div>
            <strong>${label} (${probTxt})</strong>
            &nbsp;from&nbsp;<strong>${fromTxt}</strong>
            &nbsp;→&nbsp;<strong>${toTxt}</strong>
          </div>
        `;
        scenarioListEl.appendChild(li);
      }
    }

    // ==========================================================
    // AI: rate-limit UX
    // ==========================================================
    function stopAiRetryTimer() {
      if (aiRetryTimer) clearInterval(aiRetryTimer);
      aiRetryTimer = null;
      aiRetryRemainingSec = 0;
    }

    function startAiRetryCountdown(seconds) {
      stopAiRetryTimer();
      aiRetryRemainingSec = Math.max(1, Math.floor(seconds || 10));
      if (btnRetryAi) btnRetryAi.disabled = true;
      if (aiHint) aiHint.textContent = `AI rate-limited. Retry available in ${aiRetryRemainingSec}s.`;

      aiRetryTimer = setInterval(() => {
        aiRetryRemainingSec -= 1;
        if (aiRetryRemainingSec <= 0) {
          stopAiRetryTimer();
          if (btnRetryAi) btnRetryAi.disabled = false;
          if (aiHint) aiHint.textContent = "AI retry is available now.";
          return;
        }
        if (aiHint) aiHint.textContent = `AI rate-limited. Retry available in ${aiRetryRemainingSec}s.`;
      }, 1000);
    }

    async function fetchAiPredictionForCoin(coinId, { days = 90, timeframe = "1d" } = {}) {
      const now = Date.now();

      if (!forceAiRefresh) {
        const cached = aiCache.get(coinId);
        if (cached && (now - cached.ts) <= AI_CACHE_TTL_MS) return cached.data;
      }

      const url = buildAiUrl({ coinId, days, timeframe });

      try {
        const res = await fetchJsonDetailed(url, { timeoutMs: 45000, retries: 0, mode: "cors" });
        const data = res.data;
        aiCache.set(coinId, { ts: now, data });
        return data;
      } catch (err) {
        const status = err && err.status;
        const cached = aiCache.get(coinId);
        if (status === 429 && cached && cached.data) return cached.data;

        await new Promise(r => setTimeout(r, 1200));
        const res2 = await fetchJsonDetailed(url, { timeoutMs: 45000, retries: 0, mode: "cors" });
        const data2 = res2.data;
        aiCache.set(coinId, { ts: Date.now(), data: data2 });
        return data2;
      } finally {
        forceAiRefresh = false;
      }
    }

    // ==========================================================
    // CHART
    // ==========================================================
    function yTickFormatter(v) {
      const n = Number(v);
      if (!Number.isFinite(n)) return "";
      if (Math.abs(n) >= 1000) return "$" + n.toFixed(0);
      if (Math.abs(n) >= 1) return "$" + n.toFixed(2);
      if (Math.abs(n) >= 0.01) return "$" + n.toFixed(4);
      return "$" + n.toFixed(6);
    }

    function normalizeChartPrices(prices) {
      const labels = [];
      const values = [];
      const step = Math.max(1, Math.floor(prices.length / 80));

      for (let i = 0; i < prices.length; i += step) {
        const row = prices[i];
        if (!Array.isArray(row) || row.length < 2) continue;

        const ts = row[0];
        const pn = safeNum(row[1]);
        if (pn == null) continue;

        const d = new Date(ts);
        labels.push(
          d.toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit" }) + " " +
          d.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" })
        );
        values.push(pn);
      }
      return { labels, values };
    }

    async function loadChartForCoin(coin) {
      const id = coin.id;

      let chartData = chartCache.get(id);
      if (!chartData) {
        const backendUrl = buildBackendChartUrl({ coinId: id, vsCurrency: "usd", days: 30, interval: "daily" });
        const payload = await fetchJsonWithRetry(backendUrl, { timeoutMs: 18000, retries: 0, mode: "cors" });

        const prices = Array.isArray(payload?.prices) ? payload.prices : [];
        if (!prices.length) throw new Error("Backend chart returned empty prices.");

        chartData = normalizeChartPrices(prices);
        chartCache.set(id, chartData);
      }

      const canvas = $("priceChart");
      if (!canvas) throw new Error("Chart canvas not found.");
      const ctx = canvas.getContext("2d");

      if (priceChart) priceChart.destroy();
      if (!window.Chart) throw new Error("Chart.js not loaded yet.");

      priceChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: chartData.labels,
          datasets: [{
            label: `${coin.name} – price (USD)`,
            data: chartData.values,
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.25
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: "#e5e7eb", font: { size: 10 } } }
          },
          scales: {
            x: { ticks: { color: "#9ca3af", maxRotation: 0, autoSkip: true, autoSkipPadding: 16 }, grid: { display: false } },
            y: { ticks: { color: "#9ca3af", callback: (v) => yTickFormatter(v) }, grid: { color: "rgba(55, 65, 81, 0.6)" } }
          }
        }
      });
    }

    // ==========================================================
    // SELECT COIN (with plan/usage enforcement)
    // ==========================================================
    async function handleCoinClick(id) {
      const coin = coinsRaw.find((c) => c.id === id);
      if (!coin) return;

      const access = await enforceAccessForCoin(coin.id);
      if (!access.ok) {
        alert(access.message || "Access blocked by plan limits.");
        openPricing();
        return;
      }

      selectedCoinId = id;
      if (btnRetryAi) btnRetryAi.disabled = true;
      stopAiRetryTimer();

      if (selectedNameEl) selectedNameEl.textContent = coin.name ?? "Unknown";
      if (selectedSymbolEl) selectedSymbolEl.textContent = (coin.symbol ?? "?").toUpperCase() + " / USD";
      if (selectedPriceEl) selectedPriceEl.textContent = formatPrice(coin.current_price);
      if (metricMarketCapEl) metricMarketCapEl.textContent = "$" + formatNumberAbbr(coin.market_cap ?? 0);

      if (selectedPillsEl) {
        selectedPillsEl.innerHTML = "";

        const pill24 = document.createElement("span");
        pill24.className = "pill-info " + ((coin.price_change_percentage_24h ?? 0) > 0 ? "green" : (coin.price_change_percentage_24h ?? 0) < 0 ? "red" : "");
        pill24.textContent = "24h: " + formatPercent(coin.price_change_percentage_24h);
        selectedPillsEl.appendChild(pill24);

        const pill1h = document.createElement("span");
        pill1h.className = "pill-info " + ((coin.price_change_percentage_1h_in_currency ?? 0) > 0 ? "green" : (coin.price_change_percentage_1h_in_currency ?? 0) < 0 ? "red" : "");
        pill1h.textContent = "1h: " + formatPercent(coin.price_change_percentage_1h_in_currency);
        selectedPillsEl.appendChild(pill1h);

        const pill7d = document.createElement("span");
        pill7d.className = "pill-info " + ((coin.price_change_percentage_7d_in_currency ?? 0) > 0 ? "green" : (coin.price_change_percentage_7d_in_currency ?? 0) < 0 ? "red" : "");
        pill7d.textContent = "7d: " + formatPercent(coin.price_change_percentage_7d_in_currency);
        selectedPillsEl.appendChild(pill7d);
      }

      // Chart
      try {
        if (coinCommentEl) coinCommentEl.textContent = "Loading chart from backend…";
        await loadChartForCoin(coin);
      } catch (e) {
        console.error("[Chart] failed:", e);
        if (coinCommentEl) coinCommentEl.textContent = "Chart unavailable (backend rate-limit or network). Please retry later.";
        if (priceChart) { priceChart.destroy(); priceChart = null; }
      }

      // AI
      if (metricBiasEl) metricBiasEl.textContent = "Loading AI…";
      if (coinCommentEl) coinCommentEl.textContent = "Fetching AI prediction from backend…";
      if (scenarioListEl) scenarioListEl.innerHTML = "<li>Loading scenarios…</li>";
      if (aiHint) aiHint.textContent = "AI request in progress…";

      const tf = (tfSelect?.value || "1d");
      const days = Number(daysSelect?.value || 90);
      savePrefs(tf, days);

      try {
        const ai = await fetchAiPredictionForCoin(coin.id, { days, timeframe: tf });

        const last = safeNum(ai?.last_price);
        const predicted = safeNum(ai?.predicted_price);
        const low = safeNum(ai?.prediction_interval_68?.low);
        const high = safeNum(ai?.prediction_interval_68?.high);
        const rsi = safeNum(ai?.indicators?.rsi);

        const scenarios = computeProbabilisticScenarios({ last, predicted, low, high });
        renderProbabilisticScenarioList(scenarios);

        const model = ai?.model || "ai";
        if (metricBiasEl) metricBiasEl.textContent = `${model} • RSI ${rsi != null ? rsi.toFixed(2) : "—"}`;

        if (last != null && predicted != null && low != null && high != null) {
          if (coinCommentEl) {
            coinCommentEl.textContent =
              `Prediction: ${formatPrice(predicted)} (68% range: ${formatPrice(low)} – ${formatPrice(high)}).`;
          }
          if (aiHint) aiHint.textContent = `AI OK • TF ${tf} • History ${days}d`;
        } else {
          if (coinCommentEl) coinCommentEl.textContent = "Prediction returned, but some fields are missing (check backend response).";
          if (aiHint) aiHint.textContent = "AI responded, but some values were missing.";
        }
      } catch (e) {
        console.error("[AI] failed:", e);

        const status = e && e.status;
        if (status === 429) {
          let retryAfter = 15;
          try {
            const ra = e.headers && e.headers.get && e.headers.get("Retry-After");
            const raNum = Number(ra);
            if (Number.isFinite(raNum) && raNum > 0) retryAfter = raNum;
          } catch {}

          if (metricBiasEl) metricBiasEl.textContent = "AI rate-limited";
          if (coinCommentEl) coinCommentEl.textContent = "AI rate-limited by upstream. Please retry shortly.";
          if (scenarioListEl) scenarioListEl.innerHTML = "<li>AI rate-limited. Retry shortly.</li>";
          startAiRetryCountdown(retryAfter);
          return;
        }

        if (metricBiasEl) metricBiasEl.textContent = "AI unavailable";
        if (coinCommentEl) coinCommentEl.textContent = "AI endpoint failed. Please try again later.";
        if (scenarioListEl) scenarioListEl.innerHTML = "<li>AI is temporarily unavailable.</li>";
        if (aiHint) aiHint.textContent = "AI unavailable (network/backend).";
        if (btnRetryAi) btnRetryAi.disabled = false;
      }
    }

    async function retryAiForSelectedCoin() {
      if (!selectedCoinId) return;
      forceAiRefresh = true;
      await handleCoinClick(selectedCoinId);
    }

    // ==========================================================
    // BACKEND TESTS
    // ==========================================================
    async function testHealth() {
      const url = `${BACKEND_BASE_URL.replace(/\/$/, "")}/health`;
      if (aiResult) aiResult.textContent = "Calling: " + url;
      if (btnHealth) btnHealth.disabled = true;
      try {
        const res = await fetchJsonDetailed(url, { timeoutMs: 12000, retries: 0, mode: "cors" });
        if (aiResult) aiResult.textContent = JSON.stringify(res.data, null, 2);
      } catch (err) {
        if (aiResult) aiResult.textContent = "Health error:\n" + String(err);
      } finally {
        if (btnHealth) btnHealth.disabled = false;
      }
    }

    async function handleAiBackendTest() {
      const coinId = (aiInput?.value || "bitcoin").trim();
      if (!coinId) { if (aiResult) aiResult.textContent = "Please enter a CoinGecko coin id."; return; }

      const tf = (tfSelect?.value || "1d");
      const days = Number(daysSelect?.value || 90);

      const url = buildAiUrl({ coinId, days, timeframe: tf });
      if (aiResult) aiResult.textContent = "Calling: " + url;
      if (btnTestBackend) btnTestBackend.disabled = true;

      try {
        const res = await fetchJsonDetailed(url, { timeoutMs: 45000, retries: 0, mode: "cors" });
        const data = res.data;

        const sCoin = $("ai-summary-coin");
        const sLast = $("ai-summary-last");
        const sPred = $("ai-summary-predicted");
        const sRsi  = $("ai-summary-rsi");

        if (sCoin) sCoin.textContent = data?.coin_id ?? "-";
        if (sLast) sLast.textContent = (typeof data?.last_price === "number") ? data.last_price.toFixed(6) : "-";
        if (sPred) sPred.textContent = (typeof data?.predicted_price === "number") ? data.predicted_price.toFixed(6) : "-";
        if (sRsi)  sRsi.textContent  = (typeof data?.indicators?.rsi === "number") ? data.indicators.rsi.toFixed(2) : "-";

        if (aiResult) aiResult.textContent = JSON.stringify(data, null, 2);
      } catch (err) {
        if (aiResult) aiResult.textContent = "Error while calling backend:\n" + String(err);
      } finally {
        if (btnTestBackend) btnTestBackend.disabled = false;
      }
    }

    // ==========================================================
    // Pricing modal controls
    // ==========================================================
    function openPricing() {
      if (!pricingModal) return;
      pricingModal.classList.add("show");
    }
    function closePricing() {
      if (!pricingModal) return;
      pricingModal.classList.remove("show");
    }

    // ==========================================================
    // INIT
    // ==========================================================
    function boot() {
      setSourceBadge("init", "Source: checking…");
      updateUsagePill();

      const prefs = loadPrefs();
      if (tfSelect && prefs && prefs.tf) tfSelect.value = prefs.tf;
      if (daysSelect && prefs && Number.isFinite(Number(prefs.days))) daysSelect.value = String(prefs.days);

      // Events (safe)
      on(searchInput, "input", filterCoins);

      on(sortSelect, "change", () => {
        currentSort = sortSelect.value;
        applySort();
        renderTable();
        renderMarketSnapshot();
      });

      on(refreshBtn, "click", async () => {
        const now = Date.now();
        const elapsed = now - lastManualRefreshTs;

        if (elapsed < REFRESH_MIN_INTERVAL_MS) {
          const remaining = Math.ceil((REFRESH_MIN_INTERVAL_MS - elapsed) / 1000);
          alert(`Please wait ${remaining}s before refreshing again (rate-limit protection).`);
          return;
        }

        lastManualRefreshTs = now;
        await loadMarkets({ reason: "manual" });
      });

      on(newsRefreshBtn, "click", async () => {
        await loadNews({ force: true });
      });

      on(btnTestBackend, "click", handleAiBackendTest);
      on(btnHealth, "click", testHealth);

      on(btnRetryAi, "click", async () => {
        if (btnRetryAi) btnRetryAi.disabled = true;
        stopAiRetryTimer();
        if (aiHint) aiHint.textContent = "Retrying AI…";
        await retryAiForSelectedCoin();
      });

      on(btnClearCache, "click", clearAllCaches);

      on(tfSelect, "change", () => {
        const days = Number(daysSelect?.value || 90);
        savePrefs(tfSelect.value, days);
        if (selectedCoinId) {
          if (aiHint) aiHint.textContent = "Timeframe changed. Click Retry AI to refresh scenarios.";
          if (btnRetryAi) btnRetryAi.disabled = false;
        }
      });

      on(daysSelect, "change", () => {
        const days = Number(daysSelect?.value || 90);
        savePrefs(tfSelect?.value || "1d", days);
        if (selectedCoinId) {
          if (aiHint) aiHint.textContent = "History changed. Click Retry AI to refresh scenarios.";
          if (btnRetryAi) btnRetryAi.disabled = false;
        }
      });

      // Pricing modal events
      on(btnOpenPricing, "click", openPricing);
      on(btnClosePricing, "click", closePricing);
      on(pricingModal, "click", (e) => {
        if (e && e.target === pricingModal) closePricing();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closePricing();
      });

      on(btnPlanFree, "click", () => { savePlan("free"); closePricing(); });
      on(btnPlanBasic, "click", () => { savePlan("basic"); closePricing(); });
      on(btnPlanUnlimited, "click", () => { savePlan("unlimited"); closePricing(); });

      // Initial loads
      loadMarkets({ reason: "auto" });
      loadNews({ force: false });
      renderMarketSnapshot();
    }

    document.addEventListener("DOMContentLoaded", boot);
  </script>
</body>
</html>
